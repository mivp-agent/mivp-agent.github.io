{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MOOS-IvP Agent Overview Model agnostic machine learning tooling for MOOS-IvP . Inspired by moos-ivp-pLearn this project was designed to allow for training of python ML agents for Project Aquaticus while also providing generalized software to use with any MOOS-IvP project. Note This project is still very young. As such feel free to any ask questions not answered by the documentation via a github issues . There, you can also see the current backlog. Below you can see an example MOOS-IvP mission AgentAquaticus based on Project Aquaticus . The agents being trained are rewarded by successfully grabbing and returning a flag protected by robots which circle it. The agent's actions are being determined by q-table written in NumPy . Installation This project currently supports both OSX and Linux operating systems. See the main README. README Pretty Please PLEASE Raise a GitHub issue if there is ~any~ issue with these instructions. Getting Started See the getting started page to start you on your ML path. Getting Started :fontawesome-solid-tachometer-alt:","title":"Home"},{"location":"#moos-ivp-agent","text":"","title":"MOOS-IvP Agent"},{"location":"#overview","text":"Model agnostic machine learning tooling for MOOS-IvP . Inspired by moos-ivp-pLearn this project was designed to allow for training of python ML agents for Project Aquaticus while also providing generalized software to use with any MOOS-IvP project. Note This project is still very young. As such feel free to any ask questions not answered by the documentation via a github issues . There, you can also see the current backlog. Below you can see an example MOOS-IvP mission AgentAquaticus based on Project Aquaticus . The agents being trained are rewarded by successfully grabbing and returning a flag protected by robots which circle it. The agent's actions are being determined by q-table written in NumPy .","title":"Overview"},{"location":"#installation","text":"This project currently supports both OSX and Linux operating systems. See the main README. README Pretty Please PLEASE Raise a GitHub issue if there is ~any~ issue with these instructions.","title":"Installation"},{"location":"#getting-started","text":"See the getting started page to start you on your ML path. Getting Started :fontawesome-solid-tachometer-alt:","title":"Getting Started"},{"location":"getting_started/","text":"Getting Started Note This page is currently under construction Currently the best way of getting started is to: Look at the examples from the main repository See below for suggestions on which examples to focus on depending on your background While going through examples, reference the following two pages Python API for building models MOOS-IvP Reference for configuring new missions Python API MOOS-IvP Reference If you are coming from MOOS-IvP I would recommend looking at the \"ManagerExample\" and look at the configuration blocks for the BHV_Agent . This behavior is one that does the actual connection to python land through a TCP socket. ManagerExample Then, focus on the python side of the more complex \"QTable\" mission below. If you said \"What is MOOS-IvP\" Look at the \"QTable\" example. This implements a reinforcement learning q-table . This example is trained on the Project Aquaticus scenario. It's goal is to grab a flag in virtual game of capture flag. QTable If you came from the MOOS-IvP section: The associated MOOS-IvP mission files which are in that directory are based on the moos-ivp-agent's AgentAquaticus which allows for spawning of multiple vehicles in one MOOS-IvP simulation during training time. A good config block to look at is that for pEpisodeManager which manages the resetting of vehicles to form episodes of training. Hi Joe","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"Note This page is currently under construction Currently the best way of getting started is to: Look at the examples from the main repository See below for suggestions on which examples to focus on depending on your background While going through examples, reference the following two pages Python API for building models MOOS-IvP Reference for configuring new missions Python API MOOS-IvP Reference","title":"Getting Started"},{"location":"getting_started/#if-you-are-coming-from-moos-ivp","text":"I would recommend looking at the \"ManagerExample\" and look at the configuration blocks for the BHV_Agent . This behavior is one that does the actual connection to python land through a TCP socket. ManagerExample Then, focus on the python side of the more complex \"QTable\" mission below.","title":"If you are coming from MOOS-IvP"},{"location":"getting_started/#if-you-said-what-is-moos-ivp","text":"Look at the \"QTable\" example. This implements a reinforcement learning q-table . This example is trained on the Project Aquaticus scenario. It's goal is to grab a flag in virtual game of capture flag. QTable If you came from the MOOS-IvP section: The associated MOOS-IvP mission files which are in that directory are based on the moos-ivp-agent's AgentAquaticus which allows for spawning of multiple vehicles in one MOOS-IvP simulation during training time. A good config block to look at is that for pEpisodeManager which manages the resetting of vehicles to form episodes of training.","title":"If you said \"What is MOOS-IvP\""},{"location":"getting_started/#hi-joe","text":"","title":"Hi Joe"},{"location":"moos_ivp/","text":"MOOS-IvP Reference BHV_Agent pEpisodeManager uFldFlagManagerAgent uFldTagManagerAgent Missions AgentAquaticus","title":"Index"},{"location":"moos_ivp/#moos-ivp-reference","text":"BHV_Agent pEpisodeManager uFldFlagManagerAgent uFldTagManagerAgent Missions AgentAquaticus","title":"MOOS-IvP Reference"},{"location":"moos_ivp/bhv_agent/","text":"BHV_Agent Note This page will not explain anything about the basics of MOOS-IvP. If you are new and looking for resources on this checkout their homepage . Consider completing the labs associated with MIT 2.680 if you are really serious in your goal to learn MOOS-IvP. Note BHV_Agent has only been tested in scenarios where: It has the maximum pwt out of all behaviors in the mission it is used Has perpetual = true set in it's configuration block Okay fine, a little MOOS-IvP primer Behaviors, are the \"IvP\" part of MOOS-IvP which take in \"MOOS\" variables and produce \"IvP Functions\" which dictate how the robots running MOOS-IvP should behavior. For a good primer see these 2.680 Lecture Slides (2021) . Purpose of BHV_Agent In the case of moos-ivp-agent, BHV_Agent is forwarding all \"MOOS state\" to the python ModelBridgeServer (wrapped by MissionManager ). The python ML models then make decisions on what action a robot running MOOS-IvP and BHV_Agent should take by providing a course and speed and optionally mutate the \"MOOS State\" of the robot by making posts . Configuration Note See the general Helm Autonomy reference for information about configuring behaviors in general. BHV_Agent exports three types of state from MOOS-IvP to python (Automatic): The position of the robot As defined by the NAV_X and NAV_Y moos vars. (Upon subscription): The position of other robots. As supplied by the NODE_REPORT_<VNAME> and pNodeParse (aquaticus) (Upon subscription): Any specified MOOS var Subscribing to vehicle positions The sub_vehicle configuration key is used to subscribe to vehicles based on their name. The following BHV_Agent config block shows a subscription to two vehicles with names evan and felix . Behavior = BHV_Agent { name = agent pwt = 100 perpetual = true condition = MODE == ACTIVE sub_vehicle = evan sub_vehicle = felix } Subscribing to MOOS vars The sub_var configuration key is used to subscribe to MOOS vars based on their state. The following BHV_Agent config block shows a subscription to two vars with names TAGGED and HAS_FLAG . Note As some MOOS-IvP apps have startup delays or do not post vars initially, you cannot assume that vars subscribed to will be immediately available on the python side. You are responsible for checking before you access. Behavior = BHV_Agent { name = agent pwt = 100 perpetual = true condition = MODE == ACTIVE sub_var = TAGGED sub_var = HAS_FLAG } What does state look like in Python Once the state is outputted from MissionManager , it will be in a python dictionary with the following form. All values will be translated into python's string, float, or boolean types (With the exception of the node report dictionaries). >>> msg = mgr.get_message() >>> print(msg.state) { 'NAV_X': 30.5, 'NAV_Y': -75.2, 'TAGGED': False, 'HAS_FLAG': True, 'NODE_REPORTS': { 'evan': { 'NAV_X': -60.3 'NAV_Y': 35.2 }, 'felix': { 'NAV_X': -12.3 'NAV_Y': -54.0 } } } BHV_Agent and pEpisodeManager BHV_Agent will automatically collect data from pEpisodeManager if it is present and forward that data to the python model. See the (MissionMessage)[api_pages/mission_message.md] for information on how to access this.","title":"BHV_Agent"},{"location":"moos_ivp/bhv_agent/#bhv_agent","text":"Note This page will not explain anything about the basics of MOOS-IvP. If you are new and looking for resources on this checkout their homepage . Consider completing the labs associated with MIT 2.680 if you are really serious in your goal to learn MOOS-IvP. Note BHV_Agent has only been tested in scenarios where: It has the maximum pwt out of all behaviors in the mission it is used Has perpetual = true set in it's configuration block","title":"BHV_Agent"},{"location":"moos_ivp/bhv_agent/#okay-fine-a-little-moos-ivp-primer","text":"Behaviors, are the \"IvP\" part of MOOS-IvP which take in \"MOOS\" variables and produce \"IvP Functions\" which dictate how the robots running MOOS-IvP should behavior. For a good primer see these 2.680 Lecture Slides (2021) .","title":"Okay fine, a little MOOS-IvP primer"},{"location":"moos_ivp/bhv_agent/#purpose-of-bhv_agent","text":"In the case of moos-ivp-agent, BHV_Agent is forwarding all \"MOOS state\" to the python ModelBridgeServer (wrapped by MissionManager ). The python ML models then make decisions on what action a robot running MOOS-IvP and BHV_Agent should take by providing a course and speed and optionally mutate the \"MOOS State\" of the robot by making posts .","title":"Purpose of BHV_Agent"},{"location":"moos_ivp/bhv_agent/#configuration","text":"Note See the general Helm Autonomy reference for information about configuring behaviors in general. BHV_Agent exports three types of state from MOOS-IvP to python (Automatic): The position of the robot As defined by the NAV_X and NAV_Y moos vars. (Upon subscription): The position of other robots. As supplied by the NODE_REPORT_<VNAME> and pNodeParse (aquaticus) (Upon subscription): Any specified MOOS var","title":"Configuration"},{"location":"moos_ivp/bhv_agent/#subscribing-to-vehicle-positions","text":"The sub_vehicle configuration key is used to subscribe to vehicles based on their name. The following BHV_Agent config block shows a subscription to two vehicles with names evan and felix . Behavior = BHV_Agent { name = agent pwt = 100 perpetual = true condition = MODE == ACTIVE sub_vehicle = evan sub_vehicle = felix }","title":"Subscribing to vehicle positions"},{"location":"moos_ivp/bhv_agent/#subscribing-to-moos-vars","text":"The sub_var configuration key is used to subscribe to MOOS vars based on their state. The following BHV_Agent config block shows a subscription to two vars with names TAGGED and HAS_FLAG . Note As some MOOS-IvP apps have startup delays or do not post vars initially, you cannot assume that vars subscribed to will be immediately available on the python side. You are responsible for checking before you access. Behavior = BHV_Agent { name = agent pwt = 100 perpetual = true condition = MODE == ACTIVE sub_var = TAGGED sub_var = HAS_FLAG }","title":"Subscribing to MOOS vars"},{"location":"moos_ivp/bhv_agent/#what-does-state-look-like-in-python","text":"Once the state is outputted from MissionManager , it will be in a python dictionary with the following form. All values will be translated into python's string, float, or boolean types (With the exception of the node report dictionaries). >>> msg = mgr.get_message() >>> print(msg.state) { 'NAV_X': 30.5, 'NAV_Y': -75.2, 'TAGGED': False, 'HAS_FLAG': True, 'NODE_REPORTS': { 'evan': { 'NAV_X': -60.3 'NAV_Y': 35.2 }, 'felix': { 'NAV_X': -12.3 'NAV_Y': -54.0 } } }","title":"What does state look like in Python"},{"location":"moos_ivp/bhv_agent/#bhv_agent-and-pepisodemanager","text":"BHV_Agent will automatically collect data from pEpisodeManager if it is present and forward that data to the python model. See the (MissionMessage)[api_pages/mission_message.md] for information on how to access this.","title":"BHV_Agent and pEpisodeManager"},{"location":"moos_ivp/episode_manager/","text":"pEpisodeManager Note This page will not explain anything about the basics of MOOS-IvP. If you are new and looking for resources on this checkout their homepage . Consider completing the labs associated with MIT 2.680 if you are really serious in your goal to learn MOOS-IvP. Purpose of pEpisodeManager In training of ML agents it is often desirable to split training experience into episodes that end in either success or failure. pEpisodeManager provides the capability to reset vehicles when some conditions are meet. This prevents the need to shutdown the vehicle between episodes (a expensive process). The demo below shows pEpisodeManager running during training of an agent in the AgentAquaticus mission. This mission is configured to reset agents to their home flag when they successfully capture the flag OR when they go out of bounds. Configuration There are four main components to configuring a instance of pEpisodeManager. Reset position Configuring success conditions Configuring failure conditions Reset position Note Currently, the only supported reset depth is 0. MOOS-IvP Agent is not currently compatible with submersible missions. For the basic functionality of pEpisodeManager to work, you must tell the manager where to reset the vehicle when. The following config block shows the proper usage of the reset_pos config variable where x=50 , y=-24 , and heading=240 . ProcessConfig = pEpisodeManager { AppTick = 4 CommsTick = 4 reset_pos = 50,-24,240 } If the following pEpisodeManager was started it would not reset the vehicle as it does not know when to do so. See bellow for configuration of success and failure conditions. Success & failure conditions For the manager to know when it should reset the vehicle (or equivalently when episodes should end), we need to do one of two things. Specify configuration variables for success & failure conditions. Trigger reset directly via a post to the EPISODE_MGR_CTRL moos var. This section will follow the configuration method. See below for the usage of EPISODE_MGR_CTRL. Reminder For pEpisodeManager to have access to a MOOS var it must either originate from an app also running on that vehicle or be forwarded from another vehicle. Forwarding is usually done via uFldNodeBroker or uFldShoreBroker . The following configuration block is made for Project Aquaticus and shows proper usage of the end_success_condition and end_failure_condition . The resulting behavior will be for the vehicle to reset when either tagged or in possession of the virtual flag. ProcessConfig = pEpisodeManager { AppTick = 4 CommsTick = 4 end_success_condition = (HAS_FLAG = true) end_failure_condition = (TAGGED = true) reset_pos = 50,-24,240 } More complex conditions can be specified using this format . If multiple end_success_condition or end_failure_condition lines are specified then pEpisodeManager will treat the relationship between them as an AND clause. State Transition Posts There are three state transitions which can be configured to post specified MOOS vars. The following config block shows the correct usage of the configuration variables. ProcessConfig = pEpisodeManager { AppTick = 4 CommsTick = 4 end_success_condition = (HAS_FLAG = true) end_failure_condition = (TAGGED = true) reset_pos = 50,-24,240 start_post = var=MY_VAR,val=now_starting reset_post = var=UNTAG_REQUEST,val=vname=$(VNAME) reset_post = var=MY_VAR,val=now_resetting pause_post = var=MY_VAR,val=now_pausing } TODO: Explain TODO: Max duration State & Transitions Overview There are four states which pEpisodeManager can be in. These states will be posted to the EPISODE_MGR_STATE MOOS var - RUNNING This is the main state, where MOOS variables are consumed to check if either end_success_condition s or end_failure_conditions s are satisfied at which point a state transition to STOPPING_HELM is triggered. Alternatively the vehicle can be reset through the EPISODE_MGR_STATE or by reaching the max_duration specified in the config. - STOPPING_HELM This state is used to wait for the IVPHELM_STATE MOOS var to enter the PARK state indicating that the vehicle will not be attempting to navigate during which is useful for the next state RESETING . - RESETING (working on the spelling) This state is used to wait for the vehicles NAV_X and NAV_Y to be in some tolerance of the configured reset_pos . After this condition is meet pEpisodeManager will check if a pause has been requested by use of EPISODE_MGR_STATE see here . If a pause has been requested the next state will be PAUSED and otherwise it will continue to the RUNNING state. - PAUSED Used to stop keep vehicles stopped until a EPISODE_MGR_CTRL post is made indicating that it should be started and transition to the RUNNING state. Using EPISODE_MGR_CTRL It can be useful to manually trigger state change in pEpisodeManager via a MOOS var post. For this reason pEpisodeManager listens on the EPISODE_MGR_CTRL variable. There are three \"actions\" which can be triggered via this method. start : Used when pEpisodeManager is in the PAUSED state to transition to RUNNING . hardstop : Immediately stop the current episode and enter the PAUSED state after resetting. Will report the episode as a failure in the episode report. reset : Immediately end the current episode. The state of success / failure can be set in the EPISODE_MGR_CTRL post. pause : After the current episode ends, enter the PAUSED state. These actions can be triggered by making a post where type= is followed by one of these action's names. For example, the following command uses the uPokeDB utility to make post causing the pEpisodeManager to come to a paused state after the current episode. uPokeDB alpha.moos EPISODE_MGR_CTRL=type=pause The reset can take an additional argument which specifies what value should be reported for the success state. uPokeDB alpha.moos EPISODE_MGR_CTRL=type=pause,success=true The MissionMessage python wrapper provides a pythonic way of trigging these posts. Episode Reports To report of the success / failure of each episode pEpisodeManager will post to the EPISODE_MGR_REPORT a comma separated key/value pairs. This are also helpful for debugging. The below is an example of one such report. NUM=8,SUCCESS=true,DURATION=122.0297,WILL_PAUSE=false These reports are automatically forwarded by BHV_Agent without any need for further configuration. In python MissionMessage will parse these into easily accessible variables. How it works TODO - Logic Conditions - USIM reset","title":"pEpisodeManager"},{"location":"moos_ivp/episode_manager/#pepisodemanager","text":"Note This page will not explain anything about the basics of MOOS-IvP. If you are new and looking for resources on this checkout their homepage . Consider completing the labs associated with MIT 2.680 if you are really serious in your goal to learn MOOS-IvP.","title":"pEpisodeManager"},{"location":"moos_ivp/episode_manager/#purpose-of-pepisodemanager","text":"In training of ML agents it is often desirable to split training experience into episodes that end in either success or failure. pEpisodeManager provides the capability to reset vehicles when some conditions are meet. This prevents the need to shutdown the vehicle between episodes (a expensive process). The demo below shows pEpisodeManager running during training of an agent in the AgentAquaticus mission. This mission is configured to reset agents to their home flag when they successfully capture the flag OR when they go out of bounds.","title":"Purpose of pEpisodeManager"},{"location":"moos_ivp/episode_manager/#configuration","text":"There are four main components to configuring a instance of pEpisodeManager. Reset position Configuring success conditions Configuring failure conditions","title":"Configuration"},{"location":"moos_ivp/episode_manager/#reset-position","text":"Note Currently, the only supported reset depth is 0. MOOS-IvP Agent is not currently compatible with submersible missions. For the basic functionality of pEpisodeManager to work, you must tell the manager where to reset the vehicle when. The following config block shows the proper usage of the reset_pos config variable where x=50 , y=-24 , and heading=240 . ProcessConfig = pEpisodeManager { AppTick = 4 CommsTick = 4 reset_pos = 50,-24,240 } If the following pEpisodeManager was started it would not reset the vehicle as it does not know when to do so. See bellow for configuration of success and failure conditions.","title":"Reset position"},{"location":"moos_ivp/episode_manager/#success-failure-conditions","text":"For the manager to know when it should reset the vehicle (or equivalently when episodes should end), we need to do one of two things. Specify configuration variables for success & failure conditions. Trigger reset directly via a post to the EPISODE_MGR_CTRL moos var. This section will follow the configuration method. See below for the usage of EPISODE_MGR_CTRL. Reminder For pEpisodeManager to have access to a MOOS var it must either originate from an app also running on that vehicle or be forwarded from another vehicle. Forwarding is usually done via uFldNodeBroker or uFldShoreBroker . The following configuration block is made for Project Aquaticus and shows proper usage of the end_success_condition and end_failure_condition . The resulting behavior will be for the vehicle to reset when either tagged or in possession of the virtual flag. ProcessConfig = pEpisodeManager { AppTick = 4 CommsTick = 4 end_success_condition = (HAS_FLAG = true) end_failure_condition = (TAGGED = true) reset_pos = 50,-24,240 } More complex conditions can be specified using this format . If multiple end_success_condition or end_failure_condition lines are specified then pEpisodeManager will treat the relationship between them as an AND clause.","title":"Success &amp; failure conditions"},{"location":"moos_ivp/episode_manager/#state-transition-posts","text":"There are three state transitions which can be configured to post specified MOOS vars. The following config block shows the correct usage of the configuration variables. ProcessConfig = pEpisodeManager { AppTick = 4 CommsTick = 4 end_success_condition = (HAS_FLAG = true) end_failure_condition = (TAGGED = true) reset_pos = 50,-24,240 start_post = var=MY_VAR,val=now_starting reset_post = var=UNTAG_REQUEST,val=vname=$(VNAME) reset_post = var=MY_VAR,val=now_resetting pause_post = var=MY_VAR,val=now_pausing } TODO: Explain","title":"State Transition Posts"},{"location":"moos_ivp/episode_manager/#todo-max-duration","text":"","title":"TODO: Max duration"},{"location":"moos_ivp/episode_manager/#state-transitions","text":"","title":"State &amp; Transitions"},{"location":"moos_ivp/episode_manager/#overview","text":"There are four states which pEpisodeManager can be in. These states will be posted to the EPISODE_MGR_STATE MOOS var","title":"Overview"},{"location":"moos_ivp/episode_manager/#-running","text":"This is the main state, where MOOS variables are consumed to check if either end_success_condition s or end_failure_conditions s are satisfied at which point a state transition to STOPPING_HELM is triggered. Alternatively the vehicle can be reset through the EPISODE_MGR_STATE or by reaching the max_duration specified in the config.","title":"- RUNNING"},{"location":"moos_ivp/episode_manager/#-stopping_helm","text":"This state is used to wait for the IVPHELM_STATE MOOS var to enter the PARK state indicating that the vehicle will not be attempting to navigate during which is useful for the next state RESETING .","title":"- STOPPING_HELM"},{"location":"moos_ivp/episode_manager/#-reseting-working-on-the-spelling","text":"This state is used to wait for the vehicles NAV_X and NAV_Y to be in some tolerance of the configured reset_pos . After this condition is meet pEpisodeManager will check if a pause has been requested by use of EPISODE_MGR_STATE see here . If a pause has been requested the next state will be PAUSED and otherwise it will continue to the RUNNING state.","title":"- RESETING (working on the spelling)"},{"location":"moos_ivp/episode_manager/#-paused","text":"Used to stop keep vehicles stopped until a EPISODE_MGR_CTRL post is made indicating that it should be started and transition to the RUNNING state.","title":"- PAUSED"},{"location":"moos_ivp/episode_manager/#using-episode_mgr_ctrl","text":"It can be useful to manually trigger state change in pEpisodeManager via a MOOS var post. For this reason pEpisodeManager listens on the EPISODE_MGR_CTRL variable. There are three \"actions\" which can be triggered via this method. start : Used when pEpisodeManager is in the PAUSED state to transition to RUNNING . hardstop : Immediately stop the current episode and enter the PAUSED state after resetting. Will report the episode as a failure in the episode report. reset : Immediately end the current episode. The state of success / failure can be set in the EPISODE_MGR_CTRL post. pause : After the current episode ends, enter the PAUSED state. These actions can be triggered by making a post where type= is followed by one of these action's names. For example, the following command uses the uPokeDB utility to make post causing the pEpisodeManager to come to a paused state after the current episode. uPokeDB alpha.moos EPISODE_MGR_CTRL=type=pause The reset can take an additional argument which specifies what value should be reported for the success state. uPokeDB alpha.moos EPISODE_MGR_CTRL=type=pause,success=true The MissionMessage python wrapper provides a pythonic way of trigging these posts.","title":"Using EPISODE_MGR_CTRL"},{"location":"moos_ivp/episode_manager/#episode-reports","text":"To report of the success / failure of each episode pEpisodeManager will post to the EPISODE_MGR_REPORT a comma separated key/value pairs. This are also helpful for debugging. The below is an example of one such report. NUM=8,SUCCESS=true,DURATION=122.0297,WILL_PAUSE=false These reports are automatically forwarded by BHV_Agent without any need for further configuration. In python MissionMessage will parse these into easily accessible variables.","title":"Episode Reports"},{"location":"moos_ivp/episode_manager/#how-it-works","text":"TODO - Logic Conditions - USIM reset","title":"How it works"},{"location":"moos_ivp/flag_mgr_agent/","text":"uFldFlagManagerAgent Note There is a known bug in the rending of flags by pMarineViewer. Rest assured, the vehicle will still have a flag despite this rendering issue. Purpose of uFldFlagManagerAgent To speed up the training of agents, it is helpful to have many agents train in the same simulation with without conflict. This application is a fork of Aquaticus' uFldFlagManager and is backwards compatible with the configuration options. Configuration There is only one additional flag added by this fork: infinite_flags . This flag can be set to either true or false in the config block. This allows any vehicle to grab a red or blue flag without changing the availability of that flag to other grabbing vehicles. See a example config for the uFldFlagManager app (all of which is compatible with this app) by running the following command. uFldFlagManager --example","title":"uFldFlagManagerAgent"},{"location":"moos_ivp/flag_mgr_agent/#ufldflagmanageragent","text":"Note There is a known bug in the rending of flags by pMarineViewer. Rest assured, the vehicle will still have a flag despite this rendering issue.","title":"uFldFlagManagerAgent"},{"location":"moos_ivp/flag_mgr_agent/#purpose-of-ufldflagmanageragent","text":"To speed up the training of agents, it is helpful to have many agents train in the same simulation with without conflict. This application is a fork of Aquaticus' uFldFlagManager and is backwards compatible with the configuration options.","title":"Purpose of uFldFlagManagerAgent"},{"location":"moos_ivp/flag_mgr_agent/#configuration","text":"There is only one additional flag added by this fork: infinite_flags . This flag can be set to either true or false in the config block. This allows any vehicle to grab a red or blue flag without changing the availability of that flag to other grabbing vehicles. See a example config for the uFldFlagManager app (all of which is compatible with this app) by running the following command. uFldFlagManager --example","title":"Configuration"},{"location":"moos_ivp/tag_mgr_agent/","text":"uFldTagManagerAgent Purpose of uFldTagManagerAgent To speed up the training of agents, it is helpful to have many agents train in the same simulation with without conflict. This application is a fork of Aquaticus' uFldTagManager and is backwards compatible with the configuration options. Configuration There are two components to configuring a instance of uFldTagManagerAgent. Enabling / disabling restricted tagging Specifying which vehicles can tag each other All other options can be seen by running the following command to see an example config from uFldTagManager. uFldTagManager --example Restricted tagging To enable restricted tagging you would add restrict_tagging = true to the configuration block of uFldTagManagerAgent (default it false ). When enabled, all vehicles will not be able to tag each other by default and you will need to go to the next configuration component. Can tag rules To specify that a vehicle can tag another you must provide a can_tag config line. For example, the below config lines will restrict tagging and allow the vehicle drone_21 to tag agent_11 and for drone_22 to tag agent_12 restrict_tagging = true can_tag = drone_21=agent_11 can_tag = drone_22=agent_12 Note This is not a two way street! With the above config, agent_11 will not be able to tag drone_21 .","title":"uFldTagManagerAgent"},{"location":"moos_ivp/tag_mgr_agent/#ufldtagmanageragent","text":"","title":"uFldTagManagerAgent"},{"location":"moos_ivp/tag_mgr_agent/#purpose-of-ufldtagmanageragent","text":"To speed up the training of agents, it is helpful to have many agents train in the same simulation with without conflict. This application is a fork of Aquaticus' uFldTagManager and is backwards compatible with the configuration options.","title":"Purpose of uFldTagManagerAgent"},{"location":"moos_ivp/tag_mgr_agent/#configuration","text":"There are two components to configuring a instance of uFldTagManagerAgent. Enabling / disabling restricted tagging Specifying which vehicles can tag each other All other options can be seen by running the following command to see an example config from uFldTagManager. uFldTagManager --example","title":"Configuration"},{"location":"moos_ivp/tag_mgr_agent/#restricted-tagging","text":"To enable restricted tagging you would add restrict_tagging = true to the configuration block of uFldTagManagerAgent (default it false ). When enabled, all vehicles will not be able to tag each other by default and you will need to go to the next configuration component.","title":"Restricted tagging"},{"location":"moos_ivp/tag_mgr_agent/#can-tag-rules","text":"To specify that a vehicle can tag another you must provide a can_tag config line. For example, the below config lines will restrict tagging and allow the vehicle drone_21 to tag agent_11 and for drone_22 to tag agent_12 restrict_tagging = true can_tag = drone_21=agent_11 can_tag = drone_22=agent_12 Note This is not a two way street! With the above config, agent_11 will not be able to tag drone_21 .","title":"Can tag rules"},{"location":"moos_ivp/missions/agent_aquaticus/","text":"AgentAquaticus AgentAquaticus is a fork of the Aquaticus mission which integrates the moos-ivp-agent project and provides for the ability to train multiple agents at once with one instance of a MOOS-IvP shoreside. Note You can download the original Aquaticus mission by a checkout of the moos-ivp-aquaticus repository: svn co \"https://oceanai.mit.edu/svn/moos-ivp-aquaticus-oai/trunk/\" moos-ivp-aquaticus . Usage There are two main launch scripts associated with this mission. The launch_heron.sh script launches a vehicles while the launch_shoreside.sh script is used once per simulation to launch infrastructure associated with the Aquaticus mission. Example simulation launch script can be seen here . Launching vehicles Vehicles take a number of required parameters to launch. team : Can take on the value of red or blue . This parameter, among other things, will determine the starting position of the vehicle. role : Can take on the value of agent or drone . Determines what if BHV_Agent will be spawned on the vehicle. id : Currently values 11-15 and 21-25 (inclusive) are supported for agent s and drone s respectively these, along with role, determine the vname of the vehicle. Vehicles will only be able to tag a vehicle with corresponding least significant digit (e.g. drone_21 can tag agent_11 and not agent_12 ) Note In coming updates the BHV_Agent behavior will be started on both agent and drone roles. There are a number of helpful optional parameters some of which are highlighted below. --log : Enables the writing of MOOS-IvP log files. Useful during debugging. --color=<my_color> : Used to change the color of the vehicle when rendered via pMarineViewer --behavior=<behavior_name> : Used to set initial behavior for drones. Any value placed here will show up in the ACTION field in the meta_heron.bhv file. Time Warp : A integer value with how many times the simulation should be speed up relative to real world time. Note The time warp of vehicles should correspond. Example agent launch ./launch_heron.sh red agent 11 --color=orange 10 Example drone launch ./launch_heron.sh blue drone 21 --behavior=DEFEND --color=orange 10 Launching shoreside At least one shoreside is required as it acts as the bridge for vehicle communication and manages the flag capture / tagging. Shore side takes only optional parameters. --no_gui : Used to disable the launch of pMarineViewer as it can slow the simulation. Time Warp : See vehicle launch section. Example shoreside launch ./launch_shoreside.sh --no_gui 10 Vehicle Overview Behaviors MOOS-IvP behaviors are what should determine the actions of a robot. These can either be what are referred to as \"hard coded behaviors\" or those that are produced by BHV_Agent . If extending the behavior file please use this page as a reference. Note Currently the BHV_Agent behavior is always running when the MODE == ACTIVE . This important as this contains the code which communicates with python. For hard coded behaviors, the below config block shows that anytime the ACTION != AGENT (as set when role is set to agent in the launch script) and MODE == ACTIVE the vehicle will return to their flag when they either have the flag or are tagged. set MODE = RETURN_BASE { MODE = ACTIVE (ACTION != AGENT) and ((HAS_FLAG = true) or (TAGGED = true)) } PLAY Otherwise a number of MODE s can be selected depending on the ACTION value: ATTACKING , ATTACK_LEFT , ATTACK_RIGHT , DEFENDING , STATIONING For more information see the current meta_heron.bhv and reference the IvP Helm wiki page's left hand side bar. pEpisodeManager The mission's pEpisodeManager is configured in this file and currently looks for the TAGGED == true condition for failure and receives success signals by means of a EPISODE_MGR_CTRL post from uFldFlagManagerAgent Shoreside overview The shoreside uses uFldFlagManagerAgent and uFldTagManagerAgent to allows for multi vehicle training.","title":"AgentAquaticus"},{"location":"moos_ivp/missions/agent_aquaticus/#agentaquaticus","text":"AgentAquaticus is a fork of the Aquaticus mission which integrates the moos-ivp-agent project and provides for the ability to train multiple agents at once with one instance of a MOOS-IvP shoreside. Note You can download the original Aquaticus mission by a checkout of the moos-ivp-aquaticus repository: svn co \"https://oceanai.mit.edu/svn/moos-ivp-aquaticus-oai/trunk/\" moos-ivp-aquaticus .","title":"AgentAquaticus"},{"location":"moos_ivp/missions/agent_aquaticus/#usage","text":"There are two main launch scripts associated with this mission. The launch_heron.sh script launches a vehicles while the launch_shoreside.sh script is used once per simulation to launch infrastructure associated with the Aquaticus mission. Example simulation launch script can be seen here .","title":"Usage"},{"location":"moos_ivp/missions/agent_aquaticus/#launching-vehicles","text":"Vehicles take a number of required parameters to launch. team : Can take on the value of red or blue . This parameter, among other things, will determine the starting position of the vehicle. role : Can take on the value of agent or drone . Determines what if BHV_Agent will be spawned on the vehicle. id : Currently values 11-15 and 21-25 (inclusive) are supported for agent s and drone s respectively these, along with role, determine the vname of the vehicle. Vehicles will only be able to tag a vehicle with corresponding least significant digit (e.g. drone_21 can tag agent_11 and not agent_12 ) Note In coming updates the BHV_Agent behavior will be started on both agent and drone roles. There are a number of helpful optional parameters some of which are highlighted below. --log : Enables the writing of MOOS-IvP log files. Useful during debugging. --color=<my_color> : Used to change the color of the vehicle when rendered via pMarineViewer --behavior=<behavior_name> : Used to set initial behavior for drones. Any value placed here will show up in the ACTION field in the meta_heron.bhv file. Time Warp : A integer value with how many times the simulation should be speed up relative to real world time. Note The time warp of vehicles should correspond.","title":"Launching vehicles"},{"location":"moos_ivp/missions/agent_aquaticus/#example-agent-launch","text":"./launch_heron.sh red agent 11 --color=orange 10","title":"Example agent launch"},{"location":"moos_ivp/missions/agent_aquaticus/#example-drone-launch","text":"./launch_heron.sh blue drone 21 --behavior=DEFEND --color=orange 10","title":"Example drone launch"},{"location":"moos_ivp/missions/agent_aquaticus/#launching-shoreside","text":"At least one shoreside is required as it acts as the bridge for vehicle communication and manages the flag capture / tagging. Shore side takes only optional parameters. --no_gui : Used to disable the launch of pMarineViewer as it can slow the simulation. Time Warp : See vehicle launch section.","title":"Launching shoreside"},{"location":"moos_ivp/missions/agent_aquaticus/#example-shoreside-launch","text":"./launch_shoreside.sh --no_gui 10","title":"Example shoreside launch"},{"location":"moos_ivp/missions/agent_aquaticus/#vehicle-overview","text":"","title":"Vehicle Overview"},{"location":"moos_ivp/missions/agent_aquaticus/#behaviors","text":"MOOS-IvP behaviors are what should determine the actions of a robot. These can either be what are referred to as \"hard coded behaviors\" or those that are produced by BHV_Agent . If extending the behavior file please use this page as a reference. Note Currently the BHV_Agent behavior is always running when the MODE == ACTIVE . This important as this contains the code which communicates with python. For hard coded behaviors, the below config block shows that anytime the ACTION != AGENT (as set when role is set to agent in the launch script) and MODE == ACTIVE the vehicle will return to their flag when they either have the flag or are tagged. set MODE = RETURN_BASE { MODE = ACTIVE (ACTION != AGENT) and ((HAS_FLAG = true) or (TAGGED = true)) } PLAY Otherwise a number of MODE s can be selected depending on the ACTION value: ATTACKING , ATTACK_LEFT , ATTACK_RIGHT , DEFENDING , STATIONING For more information see the current meta_heron.bhv and reference the IvP Helm wiki page's left hand side bar.","title":"Behaviors"},{"location":"moos_ivp/missions/agent_aquaticus/#pepisodemanager","text":"The mission's pEpisodeManager is configured in this file and currently looks for the TAGGED == true condition for failure and receives success signals by means of a EPISODE_MGR_CTRL post from uFldFlagManagerAgent","title":"pEpisodeManager"},{"location":"moos_ivp/missions/agent_aquaticus/#shoreside-overview","text":"The shoreside uses uFldFlagManagerAgent and uFldTagManagerAgent to allows for multi vehicle training.","title":"Shoreside overview"},{"location":"python/","text":"Python API Reference MissionManager MissionMessage Aquaticus FieldDiscretizer DiscreteFieldGrapher","title":"Index"},{"location":"python/#python-api-reference","text":"MissionManager MissionMessage Aquaticus FieldDiscretizer DiscreteFieldGrapher","title":"Python API Reference"},{"location":"python/mission_manager/","text":"Reference for MissionManager This is the primary method for interfacing with moos-ivp-agent's BHV_Agent Examples: It is recommended to use MissionManager with the python context manager from mivp_agent.manager import MissionManager with MissionManager('trainer') as mgr: mgr.wait_for(['felix', 'evan']) ... Source code in mivp_agent/manager.py class MissionManager : ''' This is the primary method for interfacing with moos-ivp-agent's BHV_Agent Examples: It is recommended to use MissionManager with the python context manager ``` from mivp_agent.manager import MissionManager with MissionManager('trainer') as mgr: mgr.wait_for(['felix', 'evan']) ... ``` ''' def __init__ ( self , task , log = True , immediate_transition = True , log_whitelist = None , id_suffix = None , output_dir = None ): ''' The initializer for MissionManager Args: task (str): For organization of saved data type is required to specify what task the MissionManager is preforming. For example a `MissionManager('trainer')` will log data under `generated_files/trainer/` in the current working directory. log (bool): Logging of agent transitions can be disabled by setting this to `False`. immediate_transition (bool): By default the the manager will assume that all messages received from BHV_Agents represent a new transition. If set to `False` one must manually tell set `msg.is_transition = True` on any objects returned from `get_message()`. This is helpful when you want to control what is considered a \"state\" in your Markov Decsion Process. log_whitelist (list): Setting this parameter will only log some transitions according to their reported `vnames`. id_suffix (str): Will be appended to the generated session id. output_dir (str): Path to a place to store files. ''' self . _msg_queue = Queue () self . _vnames = [] self . _vname_lock = Lock () self . _vehicle_count = 0 self . _episode_manager_states = {} self . _ems_lock = Lock () self . _episode_manager_nums = {} self . _emn_lock = Lock () # Dict to hold queues of vnames to reset self . _vresets = Queue () self . _thread = None self . _stop_signal = False if output_dir is None : output_dir = os . path . join ( os . path . abspath ( os . getcwd ()), DATA_DIRECTORY ) self . _log_dir = LogDirectory ( output_dir ) self . _id = self . _init_session ( id_suffix ) # Calculate the path to the directories we will be writing to. This will be created when we first use them / return them to the user. self . _model_path = os . path . join ( self . _log_dir . models_dir (), self . _id ) self . _log_path = os . path . join ( self . _log_dir . task_dir ( task ), self . _id ) self . _model_path = os . path . abspath ( self . _model_path ) self . _log_path = os . path . abspath ( self . _log_path ) self . _log = log self . _imm_transition = immediate_transition if self . _log : self . _log_whitelist = log_whitelist # Create data structs needed to log data from each vehicle self . _logs = {} self . _last_state = {} self . _last_act = {} # Go ahead and create the log path os . makedirs ( self . _log_path ) def _init_session ( self , id_suffix ): # Start the session id with the current timestamp id = str ( round ( time . time ())) # Add suffix if it exists if id_suffix is not None : id += f \"- { id_suffix } \" id = self . _log_dir . meta . registry . register ( id ) return id def model_output_dir ( self ): if not os . path . isdir ( self . _model_path ): os . makedirs ( self . _model_path ) return self . _model_path def log_output_dir ( self ): assert self . _log , \"This method should not be used, when logging is disabled\" return self . _log_path def __enter__ ( self ): self . start () return self def start ( self ): ''' It is **not recommended** to use this method directly. Instead, consider using this class with the python context manager. This method starts a thread to read from the `ModelBridgeServer`. Returns: bool: False if thread has already been started, True otherwise ''' if self . _thread is not None : return False self . _thread = Thread ( target = self . _server_thread , daemon = True ) self . _thread . start () return True def _server_thread ( self ): live_msg_list = [] address_map = {} with ModelBridgeServer () as server : while not self . _stop_signal : # Accept new clients addr = server . accept () if addr is not None : print ( f 'Got new connection: { addr } ' ) server . send_instr ( addr , INSTR_SEND_STATE ) # Listen for messages from vehicles for addr in server . _clients : msg = server . listen ( addr ) if msg is not None : with self . _vname_lock : if msg [ KEY_ID ] not in self . _vnames : print ( f 'Got new vehicle: { msg [ KEY_ID ] } ' ) vname = msg [ KEY_ID ] address_map [ vname ] = addr self . _vnames . append ( vname ) self . _vehicle_count += 1 assert address_map [ msg [ KEY_ID ]] == addr , \"Vehicle changed vname. This violates routing / logging assumptions made by MissionManager\" m = MissionMessage ( addr , msg , is_transition = self . _imm_transition ) with self . _ems_lock : self . _episode_manager_states [ m . vname ] = m . episode_state with self . _emn_lock : if m . episode_report is None : self . _episode_manager_nums [ m . vname ] = None else : self . _episode_manager_nums [ m . vname ] = m . episode_report [ 'NUM' ] live_msg_list . append ( m ) self . _msg_queue . put ( m ) # Send responses to vehicle message if there are any for i , m in enumerate ( live_msg_list ): with m . _rsp_lock : if m . _response is None : continue # If we got there is response send and remove from list live_msg_list . remove ( m ) server . send_instr ( m . _addr , m . _response ) # Do logging self . _do_logging ( m ) # Handle reseting of vehicles while not self . _vresets . empty (): vname , success = self . _vresets . get () if vname not in address_map : raise RuntimeError ( f 'Received reset for unknown vehicle: { vname } ' ) instr = INSTR_RESET_FAILURE if success : instr = INSTR_RESET_SUCCESS server . send_instr ( address_map [ vname ], instr ) # This message should only be called on msgs which have actions def _do_logging ( self , msg ): if not self . _log : return # Check in whitelist if exists if self . _log_whitelist is not None : if msg . vname not in self . _log_whitelist : return # Check if this is a new vehicle if msg . vname not in self . _logs : path = os . path . join ( self . _log_path , f \"log_ { msg . vname } \" ) self . _logs [ msg . vname ] = ProtoLogger ( path , Transition , mode = 'w' ) if msg . _is_transition : # Write a transition if this is not the first state ever if msg . vname in self . _last_state : t = Transition () t . s1 . CopyFrom ( translate . state_from_dict ( self . _last_state [ msg . vname ])) t . a . CopyFrom ( translate . action_from_dict ( self . _last_act [ msg . vname ])) t . s2 . CopyFrom ( translate . state_from_dict ( msg . state )) self . _logs [ msg . vname ] . write ( t ) # Update the storage for next transition self . _last_state [ msg . vname ] = msg . state self . _last_act [ msg . vname ] = msg . _response def are_present ( self , vnames ): ''' Used to see if a specified list of vehicles has connected to the `MissionManager` instance yet. See also: [`wait_for()`][mivp_agent.manager.MissionManager.wait_for] Args: vnames (iterable): A list / tuple of `str` values to look for ''' for vname in vnames : with self . _vname_lock : if vname not in self . _vnames : return False return True def wait_for ( self , vnames , sleep = 0.1 ): ''' Used to block until a specified list of vehicles has connect to the `MissionManager` instance. Args: vnames (iterable): A list / tuple of `str` values to look for sleep (float): Amount of time in seconds to sleep for between checks ''' while not self . are_present ( vnames ): time . sleep ( sleep ) def get_message ( self , block = True ): ''' Used as the primary method for receiving data from `BHV_Agent`. **NOTE:** Messages **MUST** be responded to as `BHV_Agent` will not send another update until it has a response to the last. Args: block (bool): A boolean specifying if the method will wait until a message present or return immediately Returns: obj: A instance of [`MissionMessage()`][mivp_agent.manager.MissionMessage] or `None` depending on the blocking behavior Example: ``` msg = mgr.get_message() NAV_X = msg.state['NAV_X'] NAV_Y = msg.state['NAV_Y'] # ... # Some processing # ... msg.act({ 'speed': 1.0 'course': 180.0 }) ``` ''' try : return self . _msg_queue . get ( block = block ) except Empty : return None def get_vehicle_count ( self ): ''' Returns: int: The amount of vehicles that have connected to this instance of `MissionManager` ''' return self . _vehicle_count def episode_state ( self , vname ): ''' This is used to interrogate the state of a connected vehicle's `pEpisodeManager` Args: vname (str): the vname of the vehicle Returns: str: The state of the `pEpisodeManager` on the vehicle ''' with self . _ems_lock : # Should be all strings so no reference odd ness return self . _episode_manager_states [ vname ] def episode_nums ( self ): ''' Returns: dict: A key, value pair maping vnames to the episode numbers of the `pEpisodeManager` app on that vehicle ''' with self . _emn_lock : return self . _episode_manager_nums . copy () def reset_vehicle ( self , vname , success = False ): # Untested self . _vresets . append (( vname , success )) def close ( self ): if self . _thread is not None : self . _stop_signal = True self . _thread . join () if self . _log : for vehicle in self . _logs : self . _logs [ vehicle ] . close () def __exit__ ( self , exc_type , exc_value , traceback ): self . close () __init__ ( self , task , log = True , immediate_transition = True , log_whitelist = None , id_suffix = None , output_dir = None ) special The initializer for MissionManager Parameters: Name Type Description Default task str For organization of saved data type is required to specify what task the MissionManager is preforming. For example a MissionManager('trainer') will log data under generated_files/trainer/ in the current working directory. required log bool Logging of agent transitions can be disabled by setting this to False . True immediate_transition bool By default the the manager will assume that all messages received from BHV_Agents represent a new transition. If set to False one must manually tell set msg.is_transition = True on any objects returned from get_message() . This is helpful when you want to control what is considered a \"state\" in your Markov Decsion Process. True log_whitelist list Setting this parameter will only log some transitions according to their reported vnames . None id_suffix str Will be appended to the generated session id. None output_dir str Path to a place to store files. None Source code in mivp_agent/manager.py def __init__ ( self , task , log = True , immediate_transition = True , log_whitelist = None , id_suffix = None , output_dir = None ): ''' The initializer for MissionManager Args: task (str): For organization of saved data type is required to specify what task the MissionManager is preforming. For example a `MissionManager('trainer')` will log data under `generated_files/trainer/` in the current working directory. log (bool): Logging of agent transitions can be disabled by setting this to `False`. immediate_transition (bool): By default the the manager will assume that all messages received from BHV_Agents represent a new transition. If set to `False` one must manually tell set `msg.is_transition = True` on any objects returned from `get_message()`. This is helpful when you want to control what is considered a \"state\" in your Markov Decsion Process. log_whitelist (list): Setting this parameter will only log some transitions according to their reported `vnames`. id_suffix (str): Will be appended to the generated session id. output_dir (str): Path to a place to store files. ''' self . _msg_queue = Queue () self . _vnames = [] self . _vname_lock = Lock () self . _vehicle_count = 0 self . _episode_manager_states = {} self . _ems_lock = Lock () self . _episode_manager_nums = {} self . _emn_lock = Lock () # Dict to hold queues of vnames to reset self . _vresets = Queue () self . _thread = None self . _stop_signal = False if output_dir is None : output_dir = os . path . join ( os . path . abspath ( os . getcwd ()), DATA_DIRECTORY ) self . _log_dir = LogDirectory ( output_dir ) self . _id = self . _init_session ( id_suffix ) # Calculate the path to the directories we will be writing to. This will be created when we first use them / return them to the user. self . _model_path = os . path . join ( self . _log_dir . models_dir (), self . _id ) self . _log_path = os . path . join ( self . _log_dir . task_dir ( task ), self . _id ) self . _model_path = os . path . abspath ( self . _model_path ) self . _log_path = os . path . abspath ( self . _log_path ) self . _log = log self . _imm_transition = immediate_transition if self . _log : self . _log_whitelist = log_whitelist # Create data structs needed to log data from each vehicle self . _logs = {} self . _last_state = {} self . _last_act = {} # Go ahead and create the log path os . makedirs ( self . _log_path ) are_present ( self , vnames ) Used to see if a specified list of vehicles has connected to the MissionManager instance yet. See also: wait_for() Parameters: Name Type Description Default vnames iterable A list / tuple of str values to look for required Source code in mivp_agent/manager.py def are_present ( self , vnames ): ''' Used to see if a specified list of vehicles has connected to the `MissionManager` instance yet. See also: [`wait_for()`][mivp_agent.manager.MissionManager.wait_for] Args: vnames (iterable): A list / tuple of `str` values to look for ''' for vname in vnames : with self . _vname_lock : if vname not in self . _vnames : return False return True episode_nums ( self ) Returns: Type Description dict A key, value pair maping vnames to the episode numbers of the pEpisodeManager app on that vehicle Source code in mivp_agent/manager.py def episode_nums ( self ): ''' Returns: dict: A key, value pair maping vnames to the episode numbers of the `pEpisodeManager` app on that vehicle ''' with self . _emn_lock : return self . _episode_manager_nums . copy () episode_state ( self , vname ) This is used to interrogate the state of a connected vehicle's pEpisodeManager Parameters: Name Type Description Default vname str the vname of the vehicle required Returns: Type Description str The state of the pEpisodeManager on the vehicle Source code in mivp_agent/manager.py def episode_state ( self , vname ): ''' This is used to interrogate the state of a connected vehicle's `pEpisodeManager` Args: vname (str): the vname of the vehicle Returns: str: The state of the `pEpisodeManager` on the vehicle ''' with self . _ems_lock : # Should be all strings so no reference odd ness return self . _episode_manager_states [ vname ] get_message ( self , block = True ) Used as the primary method for receiving data from BHV_Agent . NOTE: Messages MUST be responded to as BHV_Agent will not send another update until it has a response to the last. Parameters: Name Type Description Default block bool A boolean specifying if the method will wait until a message present or return immediately True Returns: Type Description obj A instance of MissionMessage() or None depending on the blocking behavior Examples: msg = mgr.get_message() NAV_X = msg.state['NAV_X'] NAV_Y = msg.state['NAV_Y'] # ... # Some processing # ... msg.act({ 'speed': 1.0 'course': 180.0 }) Source code in mivp_agent/manager.py def get_message ( self , block = True ): ''' Used as the primary method for receiving data from `BHV_Agent`. **NOTE:** Messages **MUST** be responded to as `BHV_Agent` will not send another update until it has a response to the last. Args: block (bool): A boolean specifying if the method will wait until a message present or return immediately Returns: obj: A instance of [`MissionMessage()`][mivp_agent.manager.MissionMessage] or `None` depending on the blocking behavior Example: ``` msg = mgr.get_message() NAV_X = msg.state['NAV_X'] NAV_Y = msg.state['NAV_Y'] # ... # Some processing # ... msg.act({ 'speed': 1.0 'course': 180.0 }) ``` ''' try : return self . _msg_queue . get ( block = block ) except Empty : return None get_vehicle_count ( self ) Returns: Type Description int The amount of vehicles that have connected to this instance of MissionManager Source code in mivp_agent/manager.py def get_vehicle_count ( self ): ''' Returns: int: The amount of vehicles that have connected to this instance of `MissionManager` ''' return self . _vehicle_count start ( self ) It is not recommended to use this method directly. Instead, consider using this class with the python context manager. This method starts a thread to read from the ModelBridgeServer . Returns: Type Description bool False if thread has already been started, True otherwise Source code in mivp_agent/manager.py def start ( self ): ''' It is **not recommended** to use this method directly. Instead, consider using this class with the python context manager. This method starts a thread to read from the `ModelBridgeServer`. Returns: bool: False if thread has already been started, True otherwise ''' if self . _thread is not None : return False self . _thread = Thread ( target = self . _server_thread , daemon = True ) self . _thread . start () return True wait_for ( self , vnames , sleep = 0.1 ) Used to block until a specified list of vehicles has connect to the MissionManager instance. Parameters: Name Type Description Default vnames iterable A list / tuple of str values to look for required sleep float Amount of time in seconds to sleep for between checks 0.1 Source code in mivp_agent/manager.py def wait_for ( self , vnames , sleep = 0.1 ): ''' Used to block until a specified list of vehicles has connect to the `MissionManager` instance. Args: vnames (iterable): A list / tuple of `str` values to look for sleep (float): Amount of time in seconds to sleep for between checks ''' while not self . are_present ( vnames ): time . sleep ( sleep )","title":"MissionManager"},{"location":"python/mission_manager/#reference-for-missionmanager","text":"This is the primary method for interfacing with moos-ivp-agent's BHV_Agent Examples: It is recommended to use MissionManager with the python context manager from mivp_agent.manager import MissionManager with MissionManager('trainer') as mgr: mgr.wait_for(['felix', 'evan']) ... Source code in mivp_agent/manager.py class MissionManager : ''' This is the primary method for interfacing with moos-ivp-agent's BHV_Agent Examples: It is recommended to use MissionManager with the python context manager ``` from mivp_agent.manager import MissionManager with MissionManager('trainer') as mgr: mgr.wait_for(['felix', 'evan']) ... ``` ''' def __init__ ( self , task , log = True , immediate_transition = True , log_whitelist = None , id_suffix = None , output_dir = None ): ''' The initializer for MissionManager Args: task (str): For organization of saved data type is required to specify what task the MissionManager is preforming. For example a `MissionManager('trainer')` will log data under `generated_files/trainer/` in the current working directory. log (bool): Logging of agent transitions can be disabled by setting this to `False`. immediate_transition (bool): By default the the manager will assume that all messages received from BHV_Agents represent a new transition. If set to `False` one must manually tell set `msg.is_transition = True` on any objects returned from `get_message()`. This is helpful when you want to control what is considered a \"state\" in your Markov Decsion Process. log_whitelist (list): Setting this parameter will only log some transitions according to their reported `vnames`. id_suffix (str): Will be appended to the generated session id. output_dir (str): Path to a place to store files. ''' self . _msg_queue = Queue () self . _vnames = [] self . _vname_lock = Lock () self . _vehicle_count = 0 self . _episode_manager_states = {} self . _ems_lock = Lock () self . _episode_manager_nums = {} self . _emn_lock = Lock () # Dict to hold queues of vnames to reset self . _vresets = Queue () self . _thread = None self . _stop_signal = False if output_dir is None : output_dir = os . path . join ( os . path . abspath ( os . getcwd ()), DATA_DIRECTORY ) self . _log_dir = LogDirectory ( output_dir ) self . _id = self . _init_session ( id_suffix ) # Calculate the path to the directories we will be writing to. This will be created when we first use them / return them to the user. self . _model_path = os . path . join ( self . _log_dir . models_dir (), self . _id ) self . _log_path = os . path . join ( self . _log_dir . task_dir ( task ), self . _id ) self . _model_path = os . path . abspath ( self . _model_path ) self . _log_path = os . path . abspath ( self . _log_path ) self . _log = log self . _imm_transition = immediate_transition if self . _log : self . _log_whitelist = log_whitelist # Create data structs needed to log data from each vehicle self . _logs = {} self . _last_state = {} self . _last_act = {} # Go ahead and create the log path os . makedirs ( self . _log_path ) def _init_session ( self , id_suffix ): # Start the session id with the current timestamp id = str ( round ( time . time ())) # Add suffix if it exists if id_suffix is not None : id += f \"- { id_suffix } \" id = self . _log_dir . meta . registry . register ( id ) return id def model_output_dir ( self ): if not os . path . isdir ( self . _model_path ): os . makedirs ( self . _model_path ) return self . _model_path def log_output_dir ( self ): assert self . _log , \"This method should not be used, when logging is disabled\" return self . _log_path def __enter__ ( self ): self . start () return self def start ( self ): ''' It is **not recommended** to use this method directly. Instead, consider using this class with the python context manager. This method starts a thread to read from the `ModelBridgeServer`. Returns: bool: False if thread has already been started, True otherwise ''' if self . _thread is not None : return False self . _thread = Thread ( target = self . _server_thread , daemon = True ) self . _thread . start () return True def _server_thread ( self ): live_msg_list = [] address_map = {} with ModelBridgeServer () as server : while not self . _stop_signal : # Accept new clients addr = server . accept () if addr is not None : print ( f 'Got new connection: { addr } ' ) server . send_instr ( addr , INSTR_SEND_STATE ) # Listen for messages from vehicles for addr in server . _clients : msg = server . listen ( addr ) if msg is not None : with self . _vname_lock : if msg [ KEY_ID ] not in self . _vnames : print ( f 'Got new vehicle: { msg [ KEY_ID ] } ' ) vname = msg [ KEY_ID ] address_map [ vname ] = addr self . _vnames . append ( vname ) self . _vehicle_count += 1 assert address_map [ msg [ KEY_ID ]] == addr , \"Vehicle changed vname. This violates routing / logging assumptions made by MissionManager\" m = MissionMessage ( addr , msg , is_transition = self . _imm_transition ) with self . _ems_lock : self . _episode_manager_states [ m . vname ] = m . episode_state with self . _emn_lock : if m . episode_report is None : self . _episode_manager_nums [ m . vname ] = None else : self . _episode_manager_nums [ m . vname ] = m . episode_report [ 'NUM' ] live_msg_list . append ( m ) self . _msg_queue . put ( m ) # Send responses to vehicle message if there are any for i , m in enumerate ( live_msg_list ): with m . _rsp_lock : if m . _response is None : continue # If we got there is response send and remove from list live_msg_list . remove ( m ) server . send_instr ( m . _addr , m . _response ) # Do logging self . _do_logging ( m ) # Handle reseting of vehicles while not self . _vresets . empty (): vname , success = self . _vresets . get () if vname not in address_map : raise RuntimeError ( f 'Received reset for unknown vehicle: { vname } ' ) instr = INSTR_RESET_FAILURE if success : instr = INSTR_RESET_SUCCESS server . send_instr ( address_map [ vname ], instr ) # This message should only be called on msgs which have actions def _do_logging ( self , msg ): if not self . _log : return # Check in whitelist if exists if self . _log_whitelist is not None : if msg . vname not in self . _log_whitelist : return # Check if this is a new vehicle if msg . vname not in self . _logs : path = os . path . join ( self . _log_path , f \"log_ { msg . vname } \" ) self . _logs [ msg . vname ] = ProtoLogger ( path , Transition , mode = 'w' ) if msg . _is_transition : # Write a transition if this is not the first state ever if msg . vname in self . _last_state : t = Transition () t . s1 . CopyFrom ( translate . state_from_dict ( self . _last_state [ msg . vname ])) t . a . CopyFrom ( translate . action_from_dict ( self . _last_act [ msg . vname ])) t . s2 . CopyFrom ( translate . state_from_dict ( msg . state )) self . _logs [ msg . vname ] . write ( t ) # Update the storage for next transition self . _last_state [ msg . vname ] = msg . state self . _last_act [ msg . vname ] = msg . _response def are_present ( self , vnames ): ''' Used to see if a specified list of vehicles has connected to the `MissionManager` instance yet. See also: [`wait_for()`][mivp_agent.manager.MissionManager.wait_for] Args: vnames (iterable): A list / tuple of `str` values to look for ''' for vname in vnames : with self . _vname_lock : if vname not in self . _vnames : return False return True def wait_for ( self , vnames , sleep = 0.1 ): ''' Used to block until a specified list of vehicles has connect to the `MissionManager` instance. Args: vnames (iterable): A list / tuple of `str` values to look for sleep (float): Amount of time in seconds to sleep for between checks ''' while not self . are_present ( vnames ): time . sleep ( sleep ) def get_message ( self , block = True ): ''' Used as the primary method for receiving data from `BHV_Agent`. **NOTE:** Messages **MUST** be responded to as `BHV_Agent` will not send another update until it has a response to the last. Args: block (bool): A boolean specifying if the method will wait until a message present or return immediately Returns: obj: A instance of [`MissionMessage()`][mivp_agent.manager.MissionMessage] or `None` depending on the blocking behavior Example: ``` msg = mgr.get_message() NAV_X = msg.state['NAV_X'] NAV_Y = msg.state['NAV_Y'] # ... # Some processing # ... msg.act({ 'speed': 1.0 'course': 180.0 }) ``` ''' try : return self . _msg_queue . get ( block = block ) except Empty : return None def get_vehicle_count ( self ): ''' Returns: int: The amount of vehicles that have connected to this instance of `MissionManager` ''' return self . _vehicle_count def episode_state ( self , vname ): ''' This is used to interrogate the state of a connected vehicle's `pEpisodeManager` Args: vname (str): the vname of the vehicle Returns: str: The state of the `pEpisodeManager` on the vehicle ''' with self . _ems_lock : # Should be all strings so no reference odd ness return self . _episode_manager_states [ vname ] def episode_nums ( self ): ''' Returns: dict: A key, value pair maping vnames to the episode numbers of the `pEpisodeManager` app on that vehicle ''' with self . _emn_lock : return self . _episode_manager_nums . copy () def reset_vehicle ( self , vname , success = False ): # Untested self . _vresets . append (( vname , success )) def close ( self ): if self . _thread is not None : self . _stop_signal = True self . _thread . join () if self . _log : for vehicle in self . _logs : self . _logs [ vehicle ] . close () def __exit__ ( self , exc_type , exc_value , traceback ): self . close ()","title":"Reference for MissionManager"},{"location":"python/mission_manager/#mivp_agent.manager.MissionManager.__init__","text":"The initializer for MissionManager Parameters: Name Type Description Default task str For organization of saved data type is required to specify what task the MissionManager is preforming. For example a MissionManager('trainer') will log data under generated_files/trainer/ in the current working directory. required log bool Logging of agent transitions can be disabled by setting this to False . True immediate_transition bool By default the the manager will assume that all messages received from BHV_Agents represent a new transition. If set to False one must manually tell set msg.is_transition = True on any objects returned from get_message() . This is helpful when you want to control what is considered a \"state\" in your Markov Decsion Process. True log_whitelist list Setting this parameter will only log some transitions according to their reported vnames . None id_suffix str Will be appended to the generated session id. None output_dir str Path to a place to store files. None Source code in mivp_agent/manager.py def __init__ ( self , task , log = True , immediate_transition = True , log_whitelist = None , id_suffix = None , output_dir = None ): ''' The initializer for MissionManager Args: task (str): For organization of saved data type is required to specify what task the MissionManager is preforming. For example a `MissionManager('trainer')` will log data under `generated_files/trainer/` in the current working directory. log (bool): Logging of agent transitions can be disabled by setting this to `False`. immediate_transition (bool): By default the the manager will assume that all messages received from BHV_Agents represent a new transition. If set to `False` one must manually tell set `msg.is_transition = True` on any objects returned from `get_message()`. This is helpful when you want to control what is considered a \"state\" in your Markov Decsion Process. log_whitelist (list): Setting this parameter will only log some transitions according to their reported `vnames`. id_suffix (str): Will be appended to the generated session id. output_dir (str): Path to a place to store files. ''' self . _msg_queue = Queue () self . _vnames = [] self . _vname_lock = Lock () self . _vehicle_count = 0 self . _episode_manager_states = {} self . _ems_lock = Lock () self . _episode_manager_nums = {} self . _emn_lock = Lock () # Dict to hold queues of vnames to reset self . _vresets = Queue () self . _thread = None self . _stop_signal = False if output_dir is None : output_dir = os . path . join ( os . path . abspath ( os . getcwd ()), DATA_DIRECTORY ) self . _log_dir = LogDirectory ( output_dir ) self . _id = self . _init_session ( id_suffix ) # Calculate the path to the directories we will be writing to. This will be created when we first use them / return them to the user. self . _model_path = os . path . join ( self . _log_dir . models_dir (), self . _id ) self . _log_path = os . path . join ( self . _log_dir . task_dir ( task ), self . _id ) self . _model_path = os . path . abspath ( self . _model_path ) self . _log_path = os . path . abspath ( self . _log_path ) self . _log = log self . _imm_transition = immediate_transition if self . _log : self . _log_whitelist = log_whitelist # Create data structs needed to log data from each vehicle self . _logs = {} self . _last_state = {} self . _last_act = {} # Go ahead and create the log path os . makedirs ( self . _log_path )","title":"__init__()"},{"location":"python/mission_manager/#mivp_agent.manager.MissionManager.are_present","text":"Used to see if a specified list of vehicles has connected to the MissionManager instance yet. See also: wait_for() Parameters: Name Type Description Default vnames iterable A list / tuple of str values to look for required Source code in mivp_agent/manager.py def are_present ( self , vnames ): ''' Used to see if a specified list of vehicles has connected to the `MissionManager` instance yet. See also: [`wait_for()`][mivp_agent.manager.MissionManager.wait_for] Args: vnames (iterable): A list / tuple of `str` values to look for ''' for vname in vnames : with self . _vname_lock : if vname not in self . _vnames : return False return True","title":"are_present()"},{"location":"python/mission_manager/#mivp_agent.manager.MissionManager.episode_nums","text":"Returns: Type Description dict A key, value pair maping vnames to the episode numbers of the pEpisodeManager app on that vehicle Source code in mivp_agent/manager.py def episode_nums ( self ): ''' Returns: dict: A key, value pair maping vnames to the episode numbers of the `pEpisodeManager` app on that vehicle ''' with self . _emn_lock : return self . _episode_manager_nums . copy ()","title":"episode_nums()"},{"location":"python/mission_manager/#mivp_agent.manager.MissionManager.episode_state","text":"This is used to interrogate the state of a connected vehicle's pEpisodeManager Parameters: Name Type Description Default vname str the vname of the vehicle required Returns: Type Description str The state of the pEpisodeManager on the vehicle Source code in mivp_agent/manager.py def episode_state ( self , vname ): ''' This is used to interrogate the state of a connected vehicle's `pEpisodeManager` Args: vname (str): the vname of the vehicle Returns: str: The state of the `pEpisodeManager` on the vehicle ''' with self . _ems_lock : # Should be all strings so no reference odd ness return self . _episode_manager_states [ vname ]","title":"episode_state()"},{"location":"python/mission_manager/#mivp_agent.manager.MissionManager.get_message","text":"Used as the primary method for receiving data from BHV_Agent . NOTE: Messages MUST be responded to as BHV_Agent will not send another update until it has a response to the last. Parameters: Name Type Description Default block bool A boolean specifying if the method will wait until a message present or return immediately True Returns: Type Description obj A instance of MissionMessage() or None depending on the blocking behavior Examples: msg = mgr.get_message() NAV_X = msg.state['NAV_X'] NAV_Y = msg.state['NAV_Y'] # ... # Some processing # ... msg.act({ 'speed': 1.0 'course': 180.0 }) Source code in mivp_agent/manager.py def get_message ( self , block = True ): ''' Used as the primary method for receiving data from `BHV_Agent`. **NOTE:** Messages **MUST** be responded to as `BHV_Agent` will not send another update until it has a response to the last. Args: block (bool): A boolean specifying if the method will wait until a message present or return immediately Returns: obj: A instance of [`MissionMessage()`][mivp_agent.manager.MissionMessage] or `None` depending on the blocking behavior Example: ``` msg = mgr.get_message() NAV_X = msg.state['NAV_X'] NAV_Y = msg.state['NAV_Y'] # ... # Some processing # ... msg.act({ 'speed': 1.0 'course': 180.0 }) ``` ''' try : return self . _msg_queue . get ( block = block ) except Empty : return None","title":"get_message()"},{"location":"python/mission_manager/#mivp_agent.manager.MissionManager.get_vehicle_count","text":"Returns: Type Description int The amount of vehicles that have connected to this instance of MissionManager Source code in mivp_agent/manager.py def get_vehicle_count ( self ): ''' Returns: int: The amount of vehicles that have connected to this instance of `MissionManager` ''' return self . _vehicle_count","title":"get_vehicle_count()"},{"location":"python/mission_manager/#mivp_agent.manager.MissionManager.start","text":"It is not recommended to use this method directly. Instead, consider using this class with the python context manager. This method starts a thread to read from the ModelBridgeServer . Returns: Type Description bool False if thread has already been started, True otherwise Source code in mivp_agent/manager.py def start ( self ): ''' It is **not recommended** to use this method directly. Instead, consider using this class with the python context manager. This method starts a thread to read from the `ModelBridgeServer`. Returns: bool: False if thread has already been started, True otherwise ''' if self . _thread is not None : return False self . _thread = Thread ( target = self . _server_thread , daemon = True ) self . _thread . start () return True","title":"start()"},{"location":"python/mission_manager/#mivp_agent.manager.MissionManager.wait_for","text":"Used to block until a specified list of vehicles has connect to the MissionManager instance. Parameters: Name Type Description Default vnames iterable A list / tuple of str values to look for required sleep float Amount of time in seconds to sleep for between checks 0.1 Source code in mivp_agent/manager.py def wait_for ( self , vnames , sleep = 0.1 ): ''' Used to block until a specified list of vehicles has connect to the `MissionManager` instance. Args: vnames (iterable): A list / tuple of `str` values to look for sleep (float): Amount of time in seconds to sleep for between checks ''' while not self . are_present ( vnames ): time . sleep ( sleep )","title":"wait_for()"},{"location":"python/mission_message/","text":"Reference for MissionMessage This class is used to parse incoming messages into attributes (see below) and provide a simple interface for responding to each message. IMPORTANT NOTE: Messages MUST be responded by one of the following methods to as BHV_Agent will not send another update until it has a response to the last. act(action) <---- Most common request_new() start() pause() stop() Attributes: Name Type Description vname str The vehicle's name which generated the message. state dict A dictionary containing key, value pairs of MOOS vars and their associated value at the time the message was created by BHV_Agent . episode_report dict or None If pEpisodeManager is present on the vehicle this message will contain any \"report\" generated by it at the end of episodes. If no pEpisodeManager is present, the value will be None . episode_state str or None If pEpisodeManager is present on the vehicle this message will be the state which that app is broadcasting. Otherwise, it will be None . Source code in mivp_agent/messages.py class MissionMessage : ''' This class is used to parse incoming messages into attributes (see below) and provide a simple interface for responding to each message. **IMPORTANT NOTE:** Messages **MUST** be responded by one of the following methods to as `BHV_Agent` will not send another update until it has a response to the last. - [`act(action)`][mivp_agent.manager.MissionMessage.act] **<---- Most common** - [`request_new()`][mivp_agent.manager.MissionMessage.request_new] - [`start()`][mivp_agent.manager.MissionMessage.start] - [`pause()`][mivp_agent.manager.MissionMessage.pause] - [`stop()`][mivp_agent.manager.MissionMessage.stop] Attributes: vname (str): The vehicle's name which generated the message. state (dict): A dictionary containing key, value pairs of MOOS vars and their associated value at the time the message was created by `BHV_Agent`. episode_report (dict or None): If `pEpisodeManager` is present on the vehicle this message will contain any \"report\" generated by it at the end of episodes. If no `pEpisodeManager` is present, the **value will be** `None`. episode_state (str or None): If `pEpisodeManager` is present on the vehicle this message will be the state which that app is broadcasting. Otherwise, it will be `None`. ''' def __init__ ( self , addr , msg , is_transition = True ): # For use my MissionManager self . _addr = addr self . _response = None self . _rsp_lock = Lock () # For use by client self . state = msg self . vname = msg [ KEY_ID ] self . episode_report = self . state [ KEY_EPISODE_MGR_REPORT ] self . episode_state = None if self . state [ KEY_EPISODE_MGR_STATE ] is not None : self . episode_state = self . state [ KEY_EPISODE_MGR_STATE ] # For use by logger self . _is_transition = is_transition def _assert_no_rsp ( self ): assert self . _response is None , 'This message has already been responded to' def mark_transition ( self ): with self . _rsp_lock : assert self . _response is None , \"A message's state can only be marked at a transition before a response to that message has been set.\" self . _is_transition = True def act ( self , action ): ''' This is used to send an action for the `BHV_Agent` to execute. Args: action (dict): An action to send (see below) Example: Actions submitted through `MissionMessage` are python dictionaries with the following **required** fields. ``` msg.act({ 'speed': 1.0 'course': 180.0 }) ``` Example: Optionally, one can add a MOOS var and value they would like to post. ``` msg.act({ 'speed': 0.0 'course': 0.0 'posts': { 'ACTION': 'ATTACK_LEFT' }, }) ``` ''' self . _assert_no_rsp () # Copy so we don't run into threading errors if client reuses the action dict instr = action . copy () if 'posts' not in action : instr [ 'posts' ] = {} validateAction ( instr ) instr [ 'ctrl_msg' ] = 'SEND_STATE' with self . _rsp_lock : self . _response = instr def start ( self ): ''' This method is used to send a message to `pEpisodeManager` to **start** an episode. The following message will be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=start' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_START def pause ( self ): ''' This method is used to send a message to `pEpisodeManager` to **pause** after the current episode. The following messagewill be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=pause' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_PAUSE def stop ( self ): ''' This method is used to send a message to `pEpisodeManager` to **hardstop** an episode immediately. The following messagewill be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=hardstop' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_STOP def request_new ( self ): ''' This method is used to send ask `BHV_Agent` to send another action. ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_SEND_STATE act ( self , action ) This is used to send an action for the BHV_Agent to execute. Parameters: Name Type Description Default action dict An action to send (see below) required Examples: Actions submitted through MissionMessage are python dictionaries with the following required fields. msg.act({ 'speed': 1.0 'course': 180.0 }) Examples: Optionally, one can add a MOOS var and value they would like to post. msg.act({ 'speed': 0.0 'course': 0.0 'posts': { 'ACTION': 'ATTACK_LEFT' }, }) Source code in mivp_agent/messages.py def act ( self , action ): ''' This is used to send an action for the `BHV_Agent` to execute. Args: action (dict): An action to send (see below) Example: Actions submitted through `MissionMessage` are python dictionaries with the following **required** fields. ``` msg.act({ 'speed': 1.0 'course': 180.0 }) ``` Example: Optionally, one can add a MOOS var and value they would like to post. ``` msg.act({ 'speed': 0.0 'course': 0.0 'posts': { 'ACTION': 'ATTACK_LEFT' }, }) ``` ''' self . _assert_no_rsp () # Copy so we don't run into threading errors if client reuses the action dict instr = action . copy () if 'posts' not in action : instr [ 'posts' ] = {} validateAction ( instr ) instr [ 'ctrl_msg' ] = 'SEND_STATE' with self . _rsp_lock : self . _response = instr pause ( self ) This method is used to send a message to pEpisodeManager to pause after the current episode. The following messagewill be constructed and dispatched. { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=pause' }, } Source code in mivp_agent/messages.py def pause ( self ): ''' This method is used to send a message to `pEpisodeManager` to **pause** after the current episode. The following messagewill be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=pause' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_PAUSE request_new ( self ) This method is used to send ask BHV_Agent to send another action. Source code in mivp_agent/messages.py def request_new ( self ): ''' This method is used to send ask `BHV_Agent` to send another action. ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_SEND_STATE start ( self ) This method is used to send a message to pEpisodeManager to start an episode. The following message will be constructed and dispatched. { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=start' }, } Source code in mivp_agent/messages.py def start ( self ): ''' This method is used to send a message to `pEpisodeManager` to **start** an episode. The following message will be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=start' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_START stop ( self ) This method is used to send a message to pEpisodeManager to hardstop an episode immediately. The following messagewill be constructed and dispatched. { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=hardstop' }, } Source code in mivp_agent/messages.py def stop ( self ): ''' This method is used to send a message to `pEpisodeManager` to **hardstop** an episode immediately. The following messagewill be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=hardstop' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_STOP","title":"MissionMessage"},{"location":"python/mission_message/#reference-for-missionmessage","text":"This class is used to parse incoming messages into attributes (see below) and provide a simple interface for responding to each message. IMPORTANT NOTE: Messages MUST be responded by one of the following methods to as BHV_Agent will not send another update until it has a response to the last. act(action) <---- Most common request_new() start() pause() stop() Attributes: Name Type Description vname str The vehicle's name which generated the message. state dict A dictionary containing key, value pairs of MOOS vars and their associated value at the time the message was created by BHV_Agent . episode_report dict or None If pEpisodeManager is present on the vehicle this message will contain any \"report\" generated by it at the end of episodes. If no pEpisodeManager is present, the value will be None . episode_state str or None If pEpisodeManager is present on the vehicle this message will be the state which that app is broadcasting. Otherwise, it will be None . Source code in mivp_agent/messages.py class MissionMessage : ''' This class is used to parse incoming messages into attributes (see below) and provide a simple interface for responding to each message. **IMPORTANT NOTE:** Messages **MUST** be responded by one of the following methods to as `BHV_Agent` will not send another update until it has a response to the last. - [`act(action)`][mivp_agent.manager.MissionMessage.act] **<---- Most common** - [`request_new()`][mivp_agent.manager.MissionMessage.request_new] - [`start()`][mivp_agent.manager.MissionMessage.start] - [`pause()`][mivp_agent.manager.MissionMessage.pause] - [`stop()`][mivp_agent.manager.MissionMessage.stop] Attributes: vname (str): The vehicle's name which generated the message. state (dict): A dictionary containing key, value pairs of MOOS vars and their associated value at the time the message was created by `BHV_Agent`. episode_report (dict or None): If `pEpisodeManager` is present on the vehicle this message will contain any \"report\" generated by it at the end of episodes. If no `pEpisodeManager` is present, the **value will be** `None`. episode_state (str or None): If `pEpisodeManager` is present on the vehicle this message will be the state which that app is broadcasting. Otherwise, it will be `None`. ''' def __init__ ( self , addr , msg , is_transition = True ): # For use my MissionManager self . _addr = addr self . _response = None self . _rsp_lock = Lock () # For use by client self . state = msg self . vname = msg [ KEY_ID ] self . episode_report = self . state [ KEY_EPISODE_MGR_REPORT ] self . episode_state = None if self . state [ KEY_EPISODE_MGR_STATE ] is not None : self . episode_state = self . state [ KEY_EPISODE_MGR_STATE ] # For use by logger self . _is_transition = is_transition def _assert_no_rsp ( self ): assert self . _response is None , 'This message has already been responded to' def mark_transition ( self ): with self . _rsp_lock : assert self . _response is None , \"A message's state can only be marked at a transition before a response to that message has been set.\" self . _is_transition = True def act ( self , action ): ''' This is used to send an action for the `BHV_Agent` to execute. Args: action (dict): An action to send (see below) Example: Actions submitted through `MissionMessage` are python dictionaries with the following **required** fields. ``` msg.act({ 'speed': 1.0 'course': 180.0 }) ``` Example: Optionally, one can add a MOOS var and value they would like to post. ``` msg.act({ 'speed': 0.0 'course': 0.0 'posts': { 'ACTION': 'ATTACK_LEFT' }, }) ``` ''' self . _assert_no_rsp () # Copy so we don't run into threading errors if client reuses the action dict instr = action . copy () if 'posts' not in action : instr [ 'posts' ] = {} validateAction ( instr ) instr [ 'ctrl_msg' ] = 'SEND_STATE' with self . _rsp_lock : self . _response = instr def start ( self ): ''' This method is used to send a message to `pEpisodeManager` to **start** an episode. The following message will be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=start' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_START def pause ( self ): ''' This method is used to send a message to `pEpisodeManager` to **pause** after the current episode. The following messagewill be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=pause' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_PAUSE def stop ( self ): ''' This method is used to send a message to `pEpisodeManager` to **hardstop** an episode immediately. The following messagewill be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=hardstop' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_STOP def request_new ( self ): ''' This method is used to send ask `BHV_Agent` to send another action. ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_SEND_STATE","title":"Reference for MissionMessage"},{"location":"python/mission_message/#mivp_agent.messages.MissionMessage.act","text":"This is used to send an action for the BHV_Agent to execute. Parameters: Name Type Description Default action dict An action to send (see below) required Examples: Actions submitted through MissionMessage are python dictionaries with the following required fields. msg.act({ 'speed': 1.0 'course': 180.0 }) Examples: Optionally, one can add a MOOS var and value they would like to post. msg.act({ 'speed': 0.0 'course': 0.0 'posts': { 'ACTION': 'ATTACK_LEFT' }, }) Source code in mivp_agent/messages.py def act ( self , action ): ''' This is used to send an action for the `BHV_Agent` to execute. Args: action (dict): An action to send (see below) Example: Actions submitted through `MissionMessage` are python dictionaries with the following **required** fields. ``` msg.act({ 'speed': 1.0 'course': 180.0 }) ``` Example: Optionally, one can add a MOOS var and value they would like to post. ``` msg.act({ 'speed': 0.0 'course': 0.0 'posts': { 'ACTION': 'ATTACK_LEFT' }, }) ``` ''' self . _assert_no_rsp () # Copy so we don't run into threading errors if client reuses the action dict instr = action . copy () if 'posts' not in action : instr [ 'posts' ] = {} validateAction ( instr ) instr [ 'ctrl_msg' ] = 'SEND_STATE' with self . _rsp_lock : self . _response = instr","title":"act()"},{"location":"python/mission_message/#mivp_agent.messages.MissionMessage.pause","text":"This method is used to send a message to pEpisodeManager to pause after the current episode. The following messagewill be constructed and dispatched. { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=pause' }, } Source code in mivp_agent/messages.py def pause ( self ): ''' This method is used to send a message to `pEpisodeManager` to **pause** after the current episode. The following messagewill be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=pause' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_PAUSE","title":"pause()"},{"location":"python/mission_message/#mivp_agent.messages.MissionMessage.request_new","text":"This method is used to send ask BHV_Agent to send another action. Source code in mivp_agent/messages.py def request_new ( self ): ''' This method is used to send ask `BHV_Agent` to send another action. ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_SEND_STATE","title":"request_new()"},{"location":"python/mission_message/#mivp_agent.messages.MissionMessage.start","text":"This method is used to send a message to pEpisodeManager to start an episode. The following message will be constructed and dispatched. { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=start' }, } Source code in mivp_agent/messages.py def start ( self ): ''' This method is used to send a message to `pEpisodeManager` to **start** an episode. The following message will be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=start' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_START","title":"start()"},{"location":"python/mission_message/#mivp_agent.messages.MissionMessage.stop","text":"This method is used to send a message to pEpisodeManager to hardstop an episode immediately. The following messagewill be constructed and dispatched. { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=hardstop' }, } Source code in mivp_agent/messages.py def stop ( self ): ''' This method is used to send a message to `pEpisodeManager` to **hardstop** an episode immediately. The following messagewill be constructed and dispatched. ``` { 'speed': 0.0, 'course': 0.0, 'posts': { 'EPISODE_MGR_CTRL': 'type=hardstop' }, } ``` ''' self . _assert_no_rsp () with self . _rsp_lock : self . _response = INSTR_STOP","title":"stop()"},{"location":"python/aquaticus/dfield_grapher/","text":"Reference for DiscreteFieldGrapher This utility uses matplotlib to graph vehicles in descrete positions as defined by an instance of FieldDiscretizer WARNING: This class is EXTREMELY ineffecient and should not be used in a loop which timing is important. Its primary use is for debuging. You can see a example of how to use this visualizer with the FieldDiscretizer here . Source code in mivp_agent/aquaticus/field.py class DiscreteFieldGrapher : ''' This utility uses matplotlib to graph vehicles in descrete positions as defined by an instance of [`FieldDiscretizer`][mivp_agent.aquaticus.field.FieldDiscretizer] **WARNING:** This class is *EXTREMELY* ineffecient and should not be used in a loop which timing is important. Its primary use is for debuging. You can see a example of how to use this visualizer with the FieldDiscretizer [here](https://github.com/mivp-agent/moos-ivp-agent/blob/main/examples/DiscreteField/run.py). ''' def __init__ ( self , discretizer ): ''' Args: discretizer (FieldDiscretizer): Used to plot discrete points and during vehicle initalization. ''' assert isinstance ( discretizer , FieldDiscretizer ), 'discretizer is of wrong type' # Store discretizer self . _discretizer = discretizer # Construct field plot plt . ion () self . _field_fig , self . _field_ax = construct_field_figure () # Add grid points to field graph for p in self . _discretizer . _point_idx_map : # Ignore the entry used for out of field points if p is None : continue self . _field_ax . plot ([ p [ 0 ]], [ p [ 1 ]], marker = '.' , markersize = 3 , color = 'dimgray' ) # Draw for first time self . _field_fig . canvas . draw () # Create data structure for storing vehicle's locations self . _vehicles = {} def init_vehicle ( self , name , color , start_pos = FIELD_OUT_BOUNDS_POINT , plot = True ): ''' Initalizes a vehicle specified by `name` in the DiscreteFieldGrapher class and it's matplotlib plot. To update the vehicles initalized by this method see [`update_vehicle()`][mivp_agent.aquaticus.field.DiscreteFieldGrapher.update_vehicle]. Args: name (str): The name (or key) to list the vehicle under. color (str): A matplotlib [named color](https://matplotlib.org/stable/gallery/color/named_colors.html). start_pos (tuple): A tuple where containing the x / y position to initally render the vehicle. plot (bool): A boolean indicating if the the plot should be redrawn after vehicle initalization. Raises: RuntimeError: If the specified `name` has already been initalized. ''' if name in self . _vehicles : raise RuntimeError ( f 'FieldGrapher alread has vehicle named \" { name } \"' ) if start_pos != FIELD_OUT_BOUNDS_POINT : start_pos = self . _discretizer . to_discrete_point ( start_pos [ 0 ], start_pos [ 1 ] ) self . _vehicles [ name ] = { 'circle' : plt . Circle ( start_pos , 2 , color = color ), 'label' : self . _field_ax . text ( start_pos [ 0 ] + 3 , start_pos [ 1 ] + 3 , name ), 'position' : start_pos } self . _field_ax . add_artist ( self . _vehicles [ name ][ 'circle' ]) if plot : self . _plot () def update_vehicle ( self , name , discrete_position , plot = True ): ''' Used to update the position of a vehicle which has been previously initalized via [`init_vehicle()`][mivp_agent.aquaticus.field.DiscreteFieldGrapher.init_vehicle] Args: name (str): The name (or key) to list the vehicle under. discrete_position (tuple): A tuple where containing the **DISCRETE** x / y position to render the vehicle at. This method **will not** pass the point through the discretizer. plot (bool): A boolean indicating if the the plot should be redrawn after vehicle update. Raises: RuntimeError: If the specified `name` has not been initalized previously. ''' if name not in self . _vehicles : raise RuntimeError ( f 'FieldGrapher cannot find vehicle with name \" { name } \"' ) if discrete_position is None : discrete_position = FIELD_OUT_BOUNDS_POINT # Remove old label position self . _vehicles [ name ][ 'label' ] . set_visible ( False ) # Update graphic self . _vehicles [ name ][ 'circle' ] . center = discrete_position self . _vehicles [ name ][ 'label' ] = self . _field_ax . text ( discrete_position [ 0 ] + 3 , discrete_position [ 1 ] + 3 , name ) self . _vehicles [ name ][ 'position' ] = discrete_position if plot : self . _plot () def _plot ( self ): # Draw the vehicles for v in self . _vehicles : self . _field_ax . draw_artist ( self . _vehicles [ v ][ 'circle' ]) self . _field_fig . canvas . flush_events () __init__ ( self , discretizer ) special Parameters: Name Type Description Default discretizer FieldDiscretizer Used to plot discrete points and during vehicle initalization. required Source code in mivp_agent/aquaticus/field.py def __init__ ( self , discretizer ): ''' Args: discretizer (FieldDiscretizer): Used to plot discrete points and during vehicle initalization. ''' assert isinstance ( discretizer , FieldDiscretizer ), 'discretizer is of wrong type' # Store discretizer self . _discretizer = discretizer # Construct field plot plt . ion () self . _field_fig , self . _field_ax = construct_field_figure () # Add grid points to field graph for p in self . _discretizer . _point_idx_map : # Ignore the entry used for out of field points if p is None : continue self . _field_ax . plot ([ p [ 0 ]], [ p [ 1 ]], marker = '.' , markersize = 3 , color = 'dimgray' ) # Draw for first time self . _field_fig . canvas . draw () # Create data structure for storing vehicle's locations self . _vehicles = {} init_vehicle ( self , name , color , start_pos = ( 30 , 10 ), plot = True ) Initalizes a vehicle specified by name in the DiscreteFieldGrapher class and it's matplotlib plot. To update the vehicles initalized by this method see update_vehicle() . Parameters: Name Type Description Default name str The name (or key) to list the vehicle under. required color str A matplotlib named color . required start_pos tuple A tuple where containing the x / y position to initally render the vehicle. (30, 10) plot bool A boolean indicating if the the plot should be redrawn after vehicle initalization. True Exceptions: Type Description RuntimeError If the specified name has already been initalized. Source code in mivp_agent/aquaticus/field.py def init_vehicle ( self , name , color , start_pos = FIELD_OUT_BOUNDS_POINT , plot = True ): ''' Initalizes a vehicle specified by `name` in the DiscreteFieldGrapher class and it's matplotlib plot. To update the vehicles initalized by this method see [`update_vehicle()`][mivp_agent.aquaticus.field.DiscreteFieldGrapher.update_vehicle]. Args: name (str): The name (or key) to list the vehicle under. color (str): A matplotlib [named color](https://matplotlib.org/stable/gallery/color/named_colors.html). start_pos (tuple): A tuple where containing the x / y position to initally render the vehicle. plot (bool): A boolean indicating if the the plot should be redrawn after vehicle initalization. Raises: RuntimeError: If the specified `name` has already been initalized. ''' if name in self . _vehicles : raise RuntimeError ( f 'FieldGrapher alread has vehicle named \" { name } \"' ) if start_pos != FIELD_OUT_BOUNDS_POINT : start_pos = self . _discretizer . to_discrete_point ( start_pos [ 0 ], start_pos [ 1 ] ) self . _vehicles [ name ] = { 'circle' : plt . Circle ( start_pos , 2 , color = color ), 'label' : self . _field_ax . text ( start_pos [ 0 ] + 3 , start_pos [ 1 ] + 3 , name ), 'position' : start_pos } self . _field_ax . add_artist ( self . _vehicles [ name ][ 'circle' ]) if plot : self . _plot () update_vehicle ( self , name , discrete_position , plot = True ) Used to update the position of a vehicle which has been previously initalized via init_vehicle() Parameters: Name Type Description Default name str The name (or key) to list the vehicle under. required discrete_position tuple A tuple where containing the DISCRETE x / y position to render the vehicle at. This method will not pass the point through the discretizer. required plot bool A boolean indicating if the the plot should be redrawn after vehicle update. True Exceptions: Type Description RuntimeError If the specified name has not been initalized previously. Source code in mivp_agent/aquaticus/field.py def update_vehicle ( self , name , discrete_position , plot = True ): ''' Used to update the position of a vehicle which has been previously initalized via [`init_vehicle()`][mivp_agent.aquaticus.field.DiscreteFieldGrapher.init_vehicle] Args: name (str): The name (or key) to list the vehicle under. discrete_position (tuple): A tuple where containing the **DISCRETE** x / y position to render the vehicle at. This method **will not** pass the point through the discretizer. plot (bool): A boolean indicating if the the plot should be redrawn after vehicle update. Raises: RuntimeError: If the specified `name` has not been initalized previously. ''' if name not in self . _vehicles : raise RuntimeError ( f 'FieldGrapher cannot find vehicle with name \" { name } \"' ) if discrete_position is None : discrete_position = FIELD_OUT_BOUNDS_POINT # Remove old label position self . _vehicles [ name ][ 'label' ] . set_visible ( False ) # Update graphic self . _vehicles [ name ][ 'circle' ] . center = discrete_position self . _vehicles [ name ][ 'label' ] = self . _field_ax . text ( discrete_position [ 0 ] + 3 , discrete_position [ 1 ] + 3 , name ) self . _vehicles [ name ][ 'position' ] = discrete_position if plot : self . _plot ()","title":"DiscreteFieldGrapher"},{"location":"python/aquaticus/dfield_grapher/#reference-for-discretefieldgrapher","text":"This utility uses matplotlib to graph vehicles in descrete positions as defined by an instance of FieldDiscretizer WARNING: This class is EXTREMELY ineffecient and should not be used in a loop which timing is important. Its primary use is for debuging. You can see a example of how to use this visualizer with the FieldDiscretizer here . Source code in mivp_agent/aquaticus/field.py class DiscreteFieldGrapher : ''' This utility uses matplotlib to graph vehicles in descrete positions as defined by an instance of [`FieldDiscretizer`][mivp_agent.aquaticus.field.FieldDiscretizer] **WARNING:** This class is *EXTREMELY* ineffecient and should not be used in a loop which timing is important. Its primary use is for debuging. You can see a example of how to use this visualizer with the FieldDiscretizer [here](https://github.com/mivp-agent/moos-ivp-agent/blob/main/examples/DiscreteField/run.py). ''' def __init__ ( self , discretizer ): ''' Args: discretizer (FieldDiscretizer): Used to plot discrete points and during vehicle initalization. ''' assert isinstance ( discretizer , FieldDiscretizer ), 'discretizer is of wrong type' # Store discretizer self . _discretizer = discretizer # Construct field plot plt . ion () self . _field_fig , self . _field_ax = construct_field_figure () # Add grid points to field graph for p in self . _discretizer . _point_idx_map : # Ignore the entry used for out of field points if p is None : continue self . _field_ax . plot ([ p [ 0 ]], [ p [ 1 ]], marker = '.' , markersize = 3 , color = 'dimgray' ) # Draw for first time self . _field_fig . canvas . draw () # Create data structure for storing vehicle's locations self . _vehicles = {} def init_vehicle ( self , name , color , start_pos = FIELD_OUT_BOUNDS_POINT , plot = True ): ''' Initalizes a vehicle specified by `name` in the DiscreteFieldGrapher class and it's matplotlib plot. To update the vehicles initalized by this method see [`update_vehicle()`][mivp_agent.aquaticus.field.DiscreteFieldGrapher.update_vehicle]. Args: name (str): The name (or key) to list the vehicle under. color (str): A matplotlib [named color](https://matplotlib.org/stable/gallery/color/named_colors.html). start_pos (tuple): A tuple where containing the x / y position to initally render the vehicle. plot (bool): A boolean indicating if the the plot should be redrawn after vehicle initalization. Raises: RuntimeError: If the specified `name` has already been initalized. ''' if name in self . _vehicles : raise RuntimeError ( f 'FieldGrapher alread has vehicle named \" { name } \"' ) if start_pos != FIELD_OUT_BOUNDS_POINT : start_pos = self . _discretizer . to_discrete_point ( start_pos [ 0 ], start_pos [ 1 ] ) self . _vehicles [ name ] = { 'circle' : plt . Circle ( start_pos , 2 , color = color ), 'label' : self . _field_ax . text ( start_pos [ 0 ] + 3 , start_pos [ 1 ] + 3 , name ), 'position' : start_pos } self . _field_ax . add_artist ( self . _vehicles [ name ][ 'circle' ]) if plot : self . _plot () def update_vehicle ( self , name , discrete_position , plot = True ): ''' Used to update the position of a vehicle which has been previously initalized via [`init_vehicle()`][mivp_agent.aquaticus.field.DiscreteFieldGrapher.init_vehicle] Args: name (str): The name (or key) to list the vehicle under. discrete_position (tuple): A tuple where containing the **DISCRETE** x / y position to render the vehicle at. This method **will not** pass the point through the discretizer. plot (bool): A boolean indicating if the the plot should be redrawn after vehicle update. Raises: RuntimeError: If the specified `name` has not been initalized previously. ''' if name not in self . _vehicles : raise RuntimeError ( f 'FieldGrapher cannot find vehicle with name \" { name } \"' ) if discrete_position is None : discrete_position = FIELD_OUT_BOUNDS_POINT # Remove old label position self . _vehicles [ name ][ 'label' ] . set_visible ( False ) # Update graphic self . _vehicles [ name ][ 'circle' ] . center = discrete_position self . _vehicles [ name ][ 'label' ] = self . _field_ax . text ( discrete_position [ 0 ] + 3 , discrete_position [ 1 ] + 3 , name ) self . _vehicles [ name ][ 'position' ] = discrete_position if plot : self . _plot () def _plot ( self ): # Draw the vehicles for v in self . _vehicles : self . _field_ax . draw_artist ( self . _vehicles [ v ][ 'circle' ]) self . _field_fig . canvas . flush_events ()","title":"Reference for DiscreteFieldGrapher"},{"location":"python/aquaticus/dfield_grapher/#mivp_agent.aquaticus.field.DiscreteFieldGrapher.__init__","text":"Parameters: Name Type Description Default discretizer FieldDiscretizer Used to plot discrete points and during vehicle initalization. required Source code in mivp_agent/aquaticus/field.py def __init__ ( self , discretizer ): ''' Args: discretizer (FieldDiscretizer): Used to plot discrete points and during vehicle initalization. ''' assert isinstance ( discretizer , FieldDiscretizer ), 'discretizer is of wrong type' # Store discretizer self . _discretizer = discretizer # Construct field plot plt . ion () self . _field_fig , self . _field_ax = construct_field_figure () # Add grid points to field graph for p in self . _discretizer . _point_idx_map : # Ignore the entry used for out of field points if p is None : continue self . _field_ax . plot ([ p [ 0 ]], [ p [ 1 ]], marker = '.' , markersize = 3 , color = 'dimgray' ) # Draw for first time self . _field_fig . canvas . draw () # Create data structure for storing vehicle's locations self . _vehicles = {}","title":"__init__()"},{"location":"python/aquaticus/dfield_grapher/#mivp_agent.aquaticus.field.DiscreteFieldGrapher.init_vehicle","text":"Initalizes a vehicle specified by name in the DiscreteFieldGrapher class and it's matplotlib plot. To update the vehicles initalized by this method see update_vehicle() . Parameters: Name Type Description Default name str The name (or key) to list the vehicle under. required color str A matplotlib named color . required start_pos tuple A tuple where containing the x / y position to initally render the vehicle. (30, 10) plot bool A boolean indicating if the the plot should be redrawn after vehicle initalization. True Exceptions: Type Description RuntimeError If the specified name has already been initalized. Source code in mivp_agent/aquaticus/field.py def init_vehicle ( self , name , color , start_pos = FIELD_OUT_BOUNDS_POINT , plot = True ): ''' Initalizes a vehicle specified by `name` in the DiscreteFieldGrapher class and it's matplotlib plot. To update the vehicles initalized by this method see [`update_vehicle()`][mivp_agent.aquaticus.field.DiscreteFieldGrapher.update_vehicle]. Args: name (str): The name (or key) to list the vehicle under. color (str): A matplotlib [named color](https://matplotlib.org/stable/gallery/color/named_colors.html). start_pos (tuple): A tuple where containing the x / y position to initally render the vehicle. plot (bool): A boolean indicating if the the plot should be redrawn after vehicle initalization. Raises: RuntimeError: If the specified `name` has already been initalized. ''' if name in self . _vehicles : raise RuntimeError ( f 'FieldGrapher alread has vehicle named \" { name } \"' ) if start_pos != FIELD_OUT_BOUNDS_POINT : start_pos = self . _discretizer . to_discrete_point ( start_pos [ 0 ], start_pos [ 1 ] ) self . _vehicles [ name ] = { 'circle' : plt . Circle ( start_pos , 2 , color = color ), 'label' : self . _field_ax . text ( start_pos [ 0 ] + 3 , start_pos [ 1 ] + 3 , name ), 'position' : start_pos } self . _field_ax . add_artist ( self . _vehicles [ name ][ 'circle' ]) if plot : self . _plot ()","title":"init_vehicle()"},{"location":"python/aquaticus/dfield_grapher/#mivp_agent.aquaticus.field.DiscreteFieldGrapher.update_vehicle","text":"Used to update the position of a vehicle which has been previously initalized via init_vehicle() Parameters: Name Type Description Default name str The name (or key) to list the vehicle under. required discrete_position tuple A tuple where containing the DISCRETE x / y position to render the vehicle at. This method will not pass the point through the discretizer. required plot bool A boolean indicating if the the plot should be redrawn after vehicle update. True Exceptions: Type Description RuntimeError If the specified name has not been initalized previously. Source code in mivp_agent/aquaticus/field.py def update_vehicle ( self , name , discrete_position , plot = True ): ''' Used to update the position of a vehicle which has been previously initalized via [`init_vehicle()`][mivp_agent.aquaticus.field.DiscreteFieldGrapher.init_vehicle] Args: name (str): The name (or key) to list the vehicle under. discrete_position (tuple): A tuple where containing the **DISCRETE** x / y position to render the vehicle at. This method **will not** pass the point through the discretizer. plot (bool): A boolean indicating if the the plot should be redrawn after vehicle update. Raises: RuntimeError: If the specified `name` has not been initalized previously. ''' if name not in self . _vehicles : raise RuntimeError ( f 'FieldGrapher cannot find vehicle with name \" { name } \"' ) if discrete_position is None : discrete_position = FIELD_OUT_BOUNDS_POINT # Remove old label position self . _vehicles [ name ][ 'label' ] . set_visible ( False ) # Update graphic self . _vehicles [ name ][ 'circle' ] . center = discrete_position self . _vehicles [ name ][ 'label' ] = self . _field_ax . text ( discrete_position [ 0 ] + 3 , discrete_position [ 1 ] + 3 , name ) self . _vehicles [ name ][ 'position' ] = discrete_position if plot : self . _plot ()","title":"update_vehicle()"},{"location":"python/aquaticus/field_discretizer/","text":"Reference for FieldDiscretizer This utility is used to transform the continuous 2d spaces into a 1d discretized space with variable resolution. The method of doing so was adapted from this source . By default it used the MIT aquaticus field lines to define the 2d space. The discrete space is a 0...n space where 0 represents an input that is outside the continuous space. See to_discrete_idx() for the primary means of translation. Source code in mivp_agent/aquaticus/field.py class FieldDiscretizer : ''' This utility is used to transform the continuous 2d spaces into a 1d discretized space with variable resolution. The method of doing so was adapted from [this source](https://stackoverflow.com/questions/62778939/python-fastest-way-to-map-continuous-coordinates-to-discrete-grid). By default it used the MIT aquaticus field lines to define the 2d space. The discrete space is a 0...n space where 0 represents an input that is **outside** the continuous space. See [`to_discrete_idx()`][mivp_agent.aquaticus.field.FieldDiscretizer.to_discrete_idx] for the primary means of translation. ''' def __init__ ( self , resolution = 6 ): ''' Args: resolution (int): This was named **poorly**. It is not the resolution but the opposite. This variable represents the step size used between discrete points. Incresing this parameter will result in a discrete space of smaller size. ''' # Find the min/max x and y in the field min = None max = None for c in FIELD_CORNERS : if min is None : min = list ( c ) # Change to list for mutability else : if min [ 0 ] > c [ 0 ]: min [ 0 ] = c [ 0 ] elif min [ 1 ] > c [ 1 ]: min [ 1 ] = c [ 1 ] if max is None : max = list ( c ) else : if max [ 0 ] < c [ 0 ]: max [ 0 ] = c [ 0 ] if max [ 1 ] < c [ 1 ]: max [ 1 ] = c [ 1 ] # Define the offset (starting point) for our grid self . _offset = np . array ([ min [ 0 ], min [ 1 ]]) # Define the spacing (resolution) for the grid self . _spacing = np . array ([ resolution , resolution ]) # Create map between grid points and an index (different than the reference's use of index) index = 1 self . _point_idx_map = { None : 0 # Used for points off the field } self . _idx_point_map = [ None ] # The below maps the space we are creating to 0...n values for both x and y. This is useful when later binning / counting the occurrences of data in after collected. For example if we have a grid x,y we can create a counter where `count[0][0]` is the count of the first discrete point on our grid. But our discrete grid starts at whatever `min` is no zero. So we must map from the discrete x,y to these indexes in the counter. We do this through `enumerate(range(....))` to map from some x to 0...n. # Note: Most times, len(self._xs) and len(self._ys) will not be the same size, and contain values for x & y values which will never be mapped to. This is to make storage in arrays easy too (easy to define a count[n][m]). self . _xs = { x : i for i , x in enumerate ( range ( min [ 0 ], max [ 0 ] + 1 , resolution ))} self . _ys = { y : i for i , y in enumerate ( range ( min [ 1 ], max [ 1 ] + 1 , resolution ))} # Interate through the x, y values to find the ones in range for x in self . _xs : for y in self . _ys : # Add to map if in bounds if in_bounds ( np . array ([ x , y ])): self . _point_idx_map [( x , y )] = index index += 1 self . _idx_point_map . append (( x , y )) self . space_size = len ( self . _point_idx_map ) # Sanity check assert self . space_size == len ( self . _idx_point_map ) def to_discrete_point ( self , nav_x , nav_y ): ''' This method translates continuous x / y coordinates into discrete x / y coordinates. Args: nav_x (float): A continuous x coordinate nav_y (float): A continuous y coordinate Returns: tuple/None: Will return a `tuple` with (x, y) of type `int` or `None` if the input is outside of the defined space. ''' d = self . _offset + np . round (( np . array ([ nav_x , nav_y ]) - self . _offset ) / self . _spacing ) * self . _spacing d = tuple ( d . astype ( int )) # Handle out of feild positions if d not in self . _point_idx_map : return None return d def to_discrete_idx ( self , nav_x , nav_y ): ''' This method translates continuous x / y coordinates into discrete 0...n index. 0 indicates that the input was outside of the defined 2d space. Args: nav_x (float): A continuous x coordinate nav_y (float): A continuous y coordinate Returns: int: A discrete index corresponding to a unique point on the 2d discrete field. ''' d = self . to_discrete_point ( nav_x , nav_y ) return self . _point_idx_map [ d ] def idx_to_discrete_point ( self , idx ): if idx >= self . space_size : raise ValueError ( 'Index is outside of discrete space' ) return self . _idx_point_map [ idx ] __init__ ( self , resolution = 6 ) special Parameters: Name Type Description Default resolution int This was named poorly . It is not the resolution but the opposite. This variable represents the step size used between discrete points. Incresing this parameter will result in a discrete space of smaller size. 6 Source code in mivp_agent/aquaticus/field.py def __init__ ( self , resolution = 6 ): ''' Args: resolution (int): This was named **poorly**. It is not the resolution but the opposite. This variable represents the step size used between discrete points. Incresing this parameter will result in a discrete space of smaller size. ''' # Find the min/max x and y in the field min = None max = None for c in FIELD_CORNERS : if min is None : min = list ( c ) # Change to list for mutability else : if min [ 0 ] > c [ 0 ]: min [ 0 ] = c [ 0 ] elif min [ 1 ] > c [ 1 ]: min [ 1 ] = c [ 1 ] if max is None : max = list ( c ) else : if max [ 0 ] < c [ 0 ]: max [ 0 ] = c [ 0 ] if max [ 1 ] < c [ 1 ]: max [ 1 ] = c [ 1 ] # Define the offset (starting point) for our grid self . _offset = np . array ([ min [ 0 ], min [ 1 ]]) # Define the spacing (resolution) for the grid self . _spacing = np . array ([ resolution , resolution ]) # Create map between grid points and an index (different than the reference's use of index) index = 1 self . _point_idx_map = { None : 0 # Used for points off the field } self . _idx_point_map = [ None ] # The below maps the space we are creating to 0...n values for both x and y. This is useful when later binning / counting the occurrences of data in after collected. For example if we have a grid x,y we can create a counter where `count[0][0]` is the count of the first discrete point on our grid. But our discrete grid starts at whatever `min` is no zero. So we must map from the discrete x,y to these indexes in the counter. We do this through `enumerate(range(....))` to map from some x to 0...n. # Note: Most times, len(self._xs) and len(self._ys) will not be the same size, and contain values for x & y values which will never be mapped to. This is to make storage in arrays easy too (easy to define a count[n][m]). self . _xs = { x : i for i , x in enumerate ( range ( min [ 0 ], max [ 0 ] + 1 , resolution ))} self . _ys = { y : i for i , y in enumerate ( range ( min [ 1 ], max [ 1 ] + 1 , resolution ))} # Interate through the x, y values to find the ones in range for x in self . _xs : for y in self . _ys : # Add to map if in bounds if in_bounds ( np . array ([ x , y ])): self . _point_idx_map [( x , y )] = index index += 1 self . _idx_point_map . append (( x , y )) self . space_size = len ( self . _point_idx_map ) # Sanity check assert self . space_size == len ( self . _idx_point_map ) to_discrete_idx ( self , nav_x , nav_y ) This method translates continuous x / y coordinates into discrete 0...n index. 0 indicates that the input was outside of the defined 2d space. Parameters: Name Type Description Default nav_x float A continuous x coordinate required nav_y float A continuous y coordinate required Returns: Type Description int A discrete index corresponding to a unique point on the 2d discrete field. Source code in mivp_agent/aquaticus/field.py def to_discrete_idx ( self , nav_x , nav_y ): ''' This method translates continuous x / y coordinates into discrete 0...n index. 0 indicates that the input was outside of the defined 2d space. Args: nav_x (float): A continuous x coordinate nav_y (float): A continuous y coordinate Returns: int: A discrete index corresponding to a unique point on the 2d discrete field. ''' d = self . to_discrete_point ( nav_x , nav_y ) return self . _point_idx_map [ d ] to_discrete_point ( self , nav_x , nav_y ) This method translates continuous x / y coordinates into discrete x / y coordinates. Parameters: Name Type Description Default nav_x float A continuous x coordinate required nav_y float A continuous y coordinate required Returns: Type Description tuple/None Will return a tuple with (x, y) of type int or None if the input is outside of the defined space. Source code in mivp_agent/aquaticus/field.py def to_discrete_point ( self , nav_x , nav_y ): ''' This method translates continuous x / y coordinates into discrete x / y coordinates. Args: nav_x (float): A continuous x coordinate nav_y (float): A continuous y coordinate Returns: tuple/None: Will return a `tuple` with (x, y) of type `int` or `None` if the input is outside of the defined space. ''' d = self . _offset + np . round (( np . array ([ nav_x , nav_y ]) - self . _offset ) / self . _spacing ) * self . _spacing d = tuple ( d . astype ( int )) # Handle out of feild positions if d not in self . _point_idx_map : return None return d","title":"FieldDiscretizer"},{"location":"python/aquaticus/field_discretizer/#reference-for-fielddiscretizer","text":"This utility is used to transform the continuous 2d spaces into a 1d discretized space with variable resolution. The method of doing so was adapted from this source . By default it used the MIT aquaticus field lines to define the 2d space. The discrete space is a 0...n space where 0 represents an input that is outside the continuous space. See to_discrete_idx() for the primary means of translation. Source code in mivp_agent/aquaticus/field.py class FieldDiscretizer : ''' This utility is used to transform the continuous 2d spaces into a 1d discretized space with variable resolution. The method of doing so was adapted from [this source](https://stackoverflow.com/questions/62778939/python-fastest-way-to-map-continuous-coordinates-to-discrete-grid). By default it used the MIT aquaticus field lines to define the 2d space. The discrete space is a 0...n space where 0 represents an input that is **outside** the continuous space. See [`to_discrete_idx()`][mivp_agent.aquaticus.field.FieldDiscretizer.to_discrete_idx] for the primary means of translation. ''' def __init__ ( self , resolution = 6 ): ''' Args: resolution (int): This was named **poorly**. It is not the resolution but the opposite. This variable represents the step size used between discrete points. Incresing this parameter will result in a discrete space of smaller size. ''' # Find the min/max x and y in the field min = None max = None for c in FIELD_CORNERS : if min is None : min = list ( c ) # Change to list for mutability else : if min [ 0 ] > c [ 0 ]: min [ 0 ] = c [ 0 ] elif min [ 1 ] > c [ 1 ]: min [ 1 ] = c [ 1 ] if max is None : max = list ( c ) else : if max [ 0 ] < c [ 0 ]: max [ 0 ] = c [ 0 ] if max [ 1 ] < c [ 1 ]: max [ 1 ] = c [ 1 ] # Define the offset (starting point) for our grid self . _offset = np . array ([ min [ 0 ], min [ 1 ]]) # Define the spacing (resolution) for the grid self . _spacing = np . array ([ resolution , resolution ]) # Create map between grid points and an index (different than the reference's use of index) index = 1 self . _point_idx_map = { None : 0 # Used for points off the field } self . _idx_point_map = [ None ] # The below maps the space we are creating to 0...n values for both x and y. This is useful when later binning / counting the occurrences of data in after collected. For example if we have a grid x,y we can create a counter where `count[0][0]` is the count of the first discrete point on our grid. But our discrete grid starts at whatever `min` is no zero. So we must map from the discrete x,y to these indexes in the counter. We do this through `enumerate(range(....))` to map from some x to 0...n. # Note: Most times, len(self._xs) and len(self._ys) will not be the same size, and contain values for x & y values which will never be mapped to. This is to make storage in arrays easy too (easy to define a count[n][m]). self . _xs = { x : i for i , x in enumerate ( range ( min [ 0 ], max [ 0 ] + 1 , resolution ))} self . _ys = { y : i for i , y in enumerate ( range ( min [ 1 ], max [ 1 ] + 1 , resolution ))} # Interate through the x, y values to find the ones in range for x in self . _xs : for y in self . _ys : # Add to map if in bounds if in_bounds ( np . array ([ x , y ])): self . _point_idx_map [( x , y )] = index index += 1 self . _idx_point_map . append (( x , y )) self . space_size = len ( self . _point_idx_map ) # Sanity check assert self . space_size == len ( self . _idx_point_map ) def to_discrete_point ( self , nav_x , nav_y ): ''' This method translates continuous x / y coordinates into discrete x / y coordinates. Args: nav_x (float): A continuous x coordinate nav_y (float): A continuous y coordinate Returns: tuple/None: Will return a `tuple` with (x, y) of type `int` or `None` if the input is outside of the defined space. ''' d = self . _offset + np . round (( np . array ([ nav_x , nav_y ]) - self . _offset ) / self . _spacing ) * self . _spacing d = tuple ( d . astype ( int )) # Handle out of feild positions if d not in self . _point_idx_map : return None return d def to_discrete_idx ( self , nav_x , nav_y ): ''' This method translates continuous x / y coordinates into discrete 0...n index. 0 indicates that the input was outside of the defined 2d space. Args: nav_x (float): A continuous x coordinate nav_y (float): A continuous y coordinate Returns: int: A discrete index corresponding to a unique point on the 2d discrete field. ''' d = self . to_discrete_point ( nav_x , nav_y ) return self . _point_idx_map [ d ] def idx_to_discrete_point ( self , idx ): if idx >= self . space_size : raise ValueError ( 'Index is outside of discrete space' ) return self . _idx_point_map [ idx ]","title":"Reference for FieldDiscretizer"},{"location":"python/aquaticus/field_discretizer/#mivp_agent.aquaticus.field.FieldDiscretizer.__init__","text":"Parameters: Name Type Description Default resolution int This was named poorly . It is not the resolution but the opposite. This variable represents the step size used between discrete points. Incresing this parameter will result in a discrete space of smaller size. 6 Source code in mivp_agent/aquaticus/field.py def __init__ ( self , resolution = 6 ): ''' Args: resolution (int): This was named **poorly**. It is not the resolution but the opposite. This variable represents the step size used between discrete points. Incresing this parameter will result in a discrete space of smaller size. ''' # Find the min/max x and y in the field min = None max = None for c in FIELD_CORNERS : if min is None : min = list ( c ) # Change to list for mutability else : if min [ 0 ] > c [ 0 ]: min [ 0 ] = c [ 0 ] elif min [ 1 ] > c [ 1 ]: min [ 1 ] = c [ 1 ] if max is None : max = list ( c ) else : if max [ 0 ] < c [ 0 ]: max [ 0 ] = c [ 0 ] if max [ 1 ] < c [ 1 ]: max [ 1 ] = c [ 1 ] # Define the offset (starting point) for our grid self . _offset = np . array ([ min [ 0 ], min [ 1 ]]) # Define the spacing (resolution) for the grid self . _spacing = np . array ([ resolution , resolution ]) # Create map between grid points and an index (different than the reference's use of index) index = 1 self . _point_idx_map = { None : 0 # Used for points off the field } self . _idx_point_map = [ None ] # The below maps the space we are creating to 0...n values for both x and y. This is useful when later binning / counting the occurrences of data in after collected. For example if we have a grid x,y we can create a counter where `count[0][0]` is the count of the first discrete point on our grid. But our discrete grid starts at whatever `min` is no zero. So we must map from the discrete x,y to these indexes in the counter. We do this through `enumerate(range(....))` to map from some x to 0...n. # Note: Most times, len(self._xs) and len(self._ys) will not be the same size, and contain values for x & y values which will never be mapped to. This is to make storage in arrays easy too (easy to define a count[n][m]). self . _xs = { x : i for i , x in enumerate ( range ( min [ 0 ], max [ 0 ] + 1 , resolution ))} self . _ys = { y : i for i , y in enumerate ( range ( min [ 1 ], max [ 1 ] + 1 , resolution ))} # Interate through the x, y values to find the ones in range for x in self . _xs : for y in self . _ys : # Add to map if in bounds if in_bounds ( np . array ([ x , y ])): self . _point_idx_map [( x , y )] = index index += 1 self . _idx_point_map . append (( x , y )) self . space_size = len ( self . _point_idx_map ) # Sanity check assert self . space_size == len ( self . _idx_point_map )","title":"__init__()"},{"location":"python/aquaticus/field_discretizer/#mivp_agent.aquaticus.field.FieldDiscretizer.to_discrete_idx","text":"This method translates continuous x / y coordinates into discrete 0...n index. 0 indicates that the input was outside of the defined 2d space. Parameters: Name Type Description Default nav_x float A continuous x coordinate required nav_y float A continuous y coordinate required Returns: Type Description int A discrete index corresponding to a unique point on the 2d discrete field. Source code in mivp_agent/aquaticus/field.py def to_discrete_idx ( self , nav_x , nav_y ): ''' This method translates continuous x / y coordinates into discrete 0...n index. 0 indicates that the input was outside of the defined 2d space. Args: nav_x (float): A continuous x coordinate nav_y (float): A continuous y coordinate Returns: int: A discrete index corresponding to a unique point on the 2d discrete field. ''' d = self . to_discrete_point ( nav_x , nav_y ) return self . _point_idx_map [ d ]","title":"to_discrete_idx()"},{"location":"python/aquaticus/field_discretizer/#mivp_agent.aquaticus.field.FieldDiscretizer.to_discrete_point","text":"This method translates continuous x / y coordinates into discrete x / y coordinates. Parameters: Name Type Description Default nav_x float A continuous x coordinate required nav_y float A continuous y coordinate required Returns: Type Description tuple/None Will return a tuple with (x, y) of type int or None if the input is outside of the defined space. Source code in mivp_agent/aquaticus/field.py def to_discrete_point ( self , nav_x , nav_y ): ''' This method translates continuous x / y coordinates into discrete x / y coordinates. Args: nav_x (float): A continuous x coordinate nav_y (float): A continuous y coordinate Returns: tuple/None: Will return a `tuple` with (x, y) of type `int` or `None` if the input is outside of the defined space. ''' d = self . _offset + np . round (( np . array ([ nav_x , nav_y ]) - self . _offset ) / self . _spacing ) * self . _spacing d = tuple ( d . astype ( int )) # Handle out of feild positions if d not in self . _point_idx_map : return None return d","title":"to_discrete_point()"}]}